\documentclass[a4paper, 11pt]{article}

\title{Keylogger}
\author{Felmeri Zsolt}
\date{}

\usepackage{graphicx}
\usepackage{multicol}
\usepackage{float}
\usepackage{ragged2e}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{algpseudocode}
\usepackage[left=4cm, right=3cm, top=3cm]{geometry}

\algnewcommand{\algorithmicand}{\textbf{ and }}
\algnewcommand{\algorithmicor}{\textbf{ or }}
\algnewcommand{\OR}{\algorithmicor}
\algnewcommand{\AND}{\algorithmicand}
\algblock[TryCatchFinally]{try}{endtry}
\algcblockdefx[TryCatchFinally]{TryCatchFinally}{catch}{endtry}
	[1]{\textbf{catch} #1}
	{\textbf{end try}}

% pszeudo kod képek helyett
% nem egyertemu a klines clinet stb
% server
% class diagram


\begin{document} 
% title page (ro)
\begin{titlepage}
\rule[20pt]{\textwidth}{1pt}
\begin{centering}
\vspace{4pt}
{\fontsize{18pt}{1} \textbf{UNIVERSITATEA SAPIENTIA DIN CLUJ-NAPOCA}}\\ \vspace{4pt}
{\fontsize{16pt}{1} \textbf{FACULTATEA DE ȘTIINȚE TEHNICE ȘI UMANISTE,\\
TÎRGU-MUREȘ\\
SPECIALIZAREA CALCULATOARE}}\\
\vspace{10em}
{\fontsize{28pt}{1} \textbf{KEYLOGGER}} \\
\vspace{10em}
{\fontsize{24pt}{1} \textbf{PROIECT DE DIPLOMĂ}}\\
\end{centering}

\vspace{15em}
\begin{noindent}
{\fontsize{16pt}{1} \textbf{Coordonator ştiințific:}}
\begin{hfill}
{\fontsize{16pt}{1} \textbf{Absolvent:}}
\end{hfill}
\end{noindent}

\begin{noindent}
\hspace{2.5em}
{\fontsize{14pt}{1} \textbf{Dr. Szántó Zoltán}}
\begin{hfill}
{\fontsize{14pt}{1} \textbf{Felmeri Zsolt}}
\end{hfill}
\end{noindent}

\vspace{5em}
\centering
{\fontsize{28pt}{1} \textbf{2020}}
\end{titlepage}

% Declaratie tip a.
\begin{titlepage}
\rule[10pt]{\textwidth}{1pt}
\begin{flushright}
{\fontsize{12pt}{1} \textbf{Model tip a.}}
\end{flushright}

\vspace{7em}
\begin{center}
{\fontsize{12pt}{1} \textbf{Declaraţie}}\\
\end{center}

\vspace{4em}
\doublespacing
\justify{\large Subsemnata/ul ............................................................., absolvent(ă) al/a \\specializării …………………………, promoţia………… cunoscând prevederile Legii Educaţiei Naţionale 1/2011 şi a Codului de etică şi deontologie profesională a Universităţii Sapientia cu privire la furt intelectual declar pe propria răspundere că prezenta lucrare de licenţă/proiect de diplomă/disertaţie se bazează pe activitatea personală, cercetarea/proiectarea este efectuată de mine, informaţiile şi datele preluate din literatura de specialitate sunt citate în mod corespunzător.}

\vspace{15em}
\begin{flushleft}
{\large Localitatea,\\
Data:}
\end{flushleft}

\begin{flushright}
{\large Absolvent\\
Semnătura…………………}
\end{flushright}

\end{titlepage}

% Declaratie tip b.
\begin{titlepage}
\rule[10pt]{\textwidth}{1pt}
\begin{flushright}
{\fontsize{12pt}{1} \textbf{Model tip b.}}
\end{flushright}

\vspace{7em}
\begin{center}
{\fontsize{12pt}{1} \textbf{Declaraţie}}\\
\end{center}

\vspace{4em}
\doublespacing
\justify{\large Subsemnata/Subsemnatul ..........................................., funcţia………………, titlul ştiinţific………………… declar pe propria răspundere că\\ ........................................., absolvent al specializării ............................ a întocmit prezenta lucrare sub îndrumarea mea.
\par În urma verificării formei finale constat că lucrarea de licenţă/proiectul de\\ diplomă/disertaţia corespunde cerințelor de formă şi conținut aprobate de Consiliul Facultăţii de Științe Tehnice și Umaniste din Târgu Mureș în baza reglementărilor Universităţii Sapientia. Luând în considerare şi Raportul generat din aplicaţia antiplagiat ''Turnitin'' consider că sunt îndeplinite cerințele referitoare la originalitatea lucrării impuse de Legea educației naționale nr. 1/2011 şi de Codul de etică şi deontologie profesională a Universităţii Sapientia, şi ca atare sunt de acord cu prezentarea şi susținerea lucrării în fața comisiei de examen de licență/diplomă/disertaţie.}

\vspace{5em}
\begin{flushleft}
{\large Localitatea,\\
Data:}
\end{flushleft}

\begin{flushright}
{\large Semnătura îndrumătorului}
\end{flushright}

\end{titlepage}

% Turnitin similarity report
\begin{titlepage}
\rule[10pt]{\textwidth}{1pt}
\end{titlepage}

% table of contents
\rule[10pt]{\textwidth}{1pt}
\renewcommand{\contentsname}{Tartalomjegyzék}
\tableofcontents
\thispagestyle{empty}
\cleardoublepage

% table of figures
\renewcommand{\listfigurename}{Ábrák jegyzéke}
\listoffigures
\thispagestyle{empty}
\cleardoublepage

% table of tables
\renewcommand{\listtablename}{Táblázatok jegyzéke}
\listoftables
\thispagestyle{empty}
\cleardoublepage

% content section (body)
\setcounter{page}{1}
\setlength{\parindent}{0.5cm}
\section{Bevezető}\label{sec:intro}
\subsection{Téma}
Témaként a keylogger-t, vagy teljes nevén keystrokelogger-t, dolgoztam ki, amely a számítógéphez csatlakoztatott billentyűzet naplózásával foglalkozik egy ``hacker'' szemszögéből nézve a dolgokat. A hackerek vagy támadók arra törekednek, hogy bizalmas információt lopjanak az áldozatuktól, mint például bejelentkezési adatok, bankkártya adatok stb.

\subsection{Célkitűzés}
Célom az volt, hogy egy támadó szerepkörébe képzeljem magam, ez által jobban megismerkedni egy támadó gondolatmenetével, hogy a későbbiekben fel tudjam használni ezt a tudást nagyobb rendszerek védelme érdekében.

\section{Elméleti megalapozás és bibliográfiai tanulmány (a téma pontos körülhatárolása érdekében végzett dokumentálódás)}\label{sec:bibl}
%mi az a keylogger
%mi a problema, mit akar megoldani
%kell definialni az adatot
%elkuldes
%kategorizalas

\subsection{Definíció}
[1] ``Keyloggers are type of a rootkit malware that capture typed keystroke events of the keyboard and save into log file, therefore, it is able to intercept sensitive information such as usernames, PINs, and passwords. Malware is termed by numerous names, such as malicious code (MC), malicious software and malcode.''

[2] Numerous [20], McGraw and Morrisett [21] define malicious code as ``any code added, changed, or removed from a software system in order to intentionally cause harm or subvert the intended function of the system.''

\subsection{Keylogger típusok}
A keylogger-ek négy fő kategóriára oszthatók: hardware, acoustic, wireless és software. Bár ezeknek különvöző a használati módjuk és az információ szerzési módszereik, egy közös dolgon osztoznak: lementik az ellopott információt és adatot egy log állományba.

\subsubsection{Wireless keylogger}
A wireless keylogger kihasználja a Bluetooth interfészeket, hogy a rögzített adatokat 100 méteres körzetben továbbítsa. Elsődleges célja az átvitt csomagok lehallgatása wireless billentyűzetről. Hátránya, hogy szükséges egy fogadó/antenna relatív közel a célpont munkakörnyékéhez.

\subsubsection{Hardware keylogger}
A hardware keylogger egy olyan fizikai eszköz, amely a billentyűzet és a számítógép között helyezkedik el. Kétféle csatlakozási módszer létezik: a keyloggerek közvetlenül összekapcsolhatók a billentyűzet és a számítógép között. A második módszer nem fizikai kapcsolatot igényel a számítógéppel, hanem a keylogger áramkör telepítését a billentyűzetbe. Ennek a módszernek az az előnye, hogy a felhasználók nem figyelhetik fizikailag a keylogger-t.

\subsubsection{Software keylogger}
A software keylogger elfogja a billentyűzet és az operációs rendszer mentén haladó adatokat. Gyűjti a billentyű karaktereit egy állományba, majd továbbítja a támadónak, aki telepítette a keylogger-t.

\subsubsection{Acoustic keylogger}
A hardware keylogger-rel ellentétben az acoustic keylogger elemzésekor rögzíti az egyes billentyűleütések hangját. Különleges felszerelés szükséges a felhasználó gépelés hangjának meghallgatásához. Parabolikus mikrofonokat használnak nagy távolság alapuló rögzítésre, ezért ezt a mikrofont arra használják, hogy a billentyűzet hangját 30 méter távolságból vegye fel a célzott helyről.


\section{A rendszer specifikációi és architektúrája (szoftverek és hardverek esetében)}\label{sec:specs_and_arch}
%virtualis gepek -> meresek, hany kliensd bir el
%kiserletek, grafikonok
%kovetelmeny specs - func, nem func
%architektura osszes lenyeges komponens

\subsection{Nem funkcionális követelmények}
A szoftver működik windows, linux és darwin rendszerek alatt, a verzió nem befolyásolja. A rendszeren szükséges telepíteni a python 3.x verzióját, mivel olyan modulok vannak használatban, amelyeket a python 2.x nem ismer. Ez egy olyan szoftver, amelyet törvényes és törvénytelen dolgogra is lehet használni. Törvényesen például monitorizálni a céges alkalmazottak munka időszakában lebonyolított tevékenységeket. Törvénytelen például, ha valaki arra használja, hogy ellopjon bizalmas információkat személyektől. Ez a használón múlik, hogy melyik utat választja.

A python 3.x verzióhoz szükséges modulok a futtatáshoz:
\begin{multicols}{2}
\begin{itemize}
\item pynput = 1.6.8
\item pyautogui
\item pyaudio
\item wave
\item socket
\item opencv
\item getpass
\item os
\item sys
\item threading
\item datetime
\item smtplib
\item email
\item imaplib
\item shutil
\item platform
\item tkinter
\item logging
\item pyinstaller
\end{itemize}
\end{multicols}
\cleardoublepage
A \textbf{pynput} modul a billentyűzet és az egér eseménykezelését teszi lehetővé. Egy régebbi verzióját kell használni ($1.6.8$), mert a legújabb ($1.7.2$) nem kompatibilis a fordító programokkal.

A \textbf{pyautogui} modullal képernyőképet lehet készíteni, és azt elmenti egy fájlba a rendszeren. A végrehajtásához szükséges, hogy a felhasznéló képernyőképet tudjon készíteni önmagénak.

A \textbf{pyaudio} és a \textbf{wave} modulok a hangfelvétel készítésében használandók. A \textbf{pyaudio} egy listát állít elő a hanganyaggal, ahogyan azt ábrázolni lehet binárisan, míg a \textbf{wave} ebből a lisából egy $.wav$ kiterjesztésű állományt készít. Ehez szükséges, hogy a felhasználónak legyen mikrofonja, ami csatlakoztatva van a számítógéphez.

A hálózati kapcsolat megteremtéséhez a \textbf{socket} modul segít. Ez meghatározza a kapcsolat milyenségét, hogy hányan csatlakozhatnak a szerverhez és hogy a szerver meddig várjon a kliensre.

Az \textbf{opencv} modul képek vagy videók feldolgozásában használható, például webkamerakép készítésére.

A \textbf{getpass}, \textbf{os}, \textbf{sys}, \textbf{shutil} és \textbf{platform} modulok a rendszerfüggvények elérését biztosítja. A rendszerinformációit függvények használata, mint például a processzor specifikációi, a bejelentkezett felhasználo felhasználóneve, a számítógép neve, a rendszer verziószáma stb.

A \textbf{threading} modul segítségével új, párhuzamos szálakat hoszhatunk létre. Ez segít több feladat elvégzésében egymást nem blokkolva.

A \textbf{datetime} modullal le lehet kérni az aktuális időt, olyan formátumban amilyenben a használó szeretné. %https://www.programiz.com/python-programming/datetime/strftime

Az \textbf{smtplib}, \textbf{imaplib} és \textbf{email} modulok segítsígével lehet kapcsolódni a gmail szerveréhez üzenet küldés vagy fogadás céljából. Az \textbf{imaplib} modullal lehet kapcsolatot teremteni olvasásra, míg az \textbf{smtplib} modullal írásra, azaz küldésre. Az \textbf{email} modul tartalmazza azokat az osztályokat, amelyek szükségesek egy email objektum létrehozásában és kódolásában.

A \textbf{tkinter} modul a GUI elkészítésére használandó, ez felel a megjelenítésben.

A \textbf{logging} modul segítségével visszajelzéseket adunk a szoftvertől a felhasználónak, hogy lehessen követni az aktuális feladat menetét. Ehez szükséges egy $logging.conf$ állomány, maely béállítja a loggolási opciókat.

A \textbf{pyinstaller} modul egy fordító program, amely python kódból futtatható fájlt készít. Lefordításra csak a kliens kerül, mert azt kell az áldozat rendszerére telepíteni, úgy, hogy a háttérben fusson. Ezt be lehet állítani a $w$ opcióval windows és OS X rendszereken, míg *NIX rendszereken nem veszi számításba ezt az opciót. A $onefile$ opció összesűríti egy futtathatóvá, ez által lehetővé teszi, hogy ne kelljen más szükséges állományokat is telepíteni az áldozat rendszerére. Be lehet állítani a futtatható fájl nevét ($name$ opció) és ikonját is ($icon$ opció).

%Teljesítmény...

%Karbantarthatóság...

\subsection{Funkcionális követelmények}

\section{A részletes tervezés}\label{sec:plan}
A projekt három fő komponensből épül fel: szerver, kliens és GUI. Ezen felül található egy mellék állomány, amelyben a szerver és a kliens számára hasznos fuggvények vannak implementálva.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/class\ diagram}
\caption{osztály diagram}
\label{fig:classdia}
\end{figure}
\subsection{Szerver}\label{subsec:server}
Előszőr, hogy működjön a gyakori operációs rendszereken (Windows, Linux, MacOS) meg kell nézni, hogy melyiken futtatjuk. Ezt a platform modul system függvény segítségével tudjuk megnézni:
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture}
\caption{rendszernév}
\label{fig:sysname}
\end{figure}

\begin{algorithmic}[H]
\State $sys\_name \gets rendszer neve$
\If{$sys\_name =\ 'windows'$}
	\State $temp\_path \gets$ folder, amely tartalmazza a temporális állományokat windows-on
\ElsIf{$sys\_name =\ 'linux' \OR sys\_name =\ 'darwin'$}
	\State $temp\_path \gets$ folder, amely tartalmazza a temporális állományokat linux-on és macos-on
\Else
	\State \textbf{kiír:} $Unknown\ system!$
	\State \textbf{kiír:} $Exiting...$
\EndIf
\end{algorithmic}

\noindent Ha nem a három operációs rendszer közé tartozik, akkor kilép a program. Itt a rendszer neve meghatározza a $temp\_path$ változót, ami a későbbiekben arra lesz használva, hogy bizonyos adatokat elmentsen. A $temp\_path$ változó a temporális mappa elérhetőségét tartalmazza. Ez linux és darwin (MacOS) rendszereken megegyező, míg windows rendszeren különbözik.

Ahogyan a Figure \ref{fig:classdia}-en látható, a szerver oldalon három osztály talalható (Server, Keylogger, MenuHandler) és ehez még hozzácsatolódik a GUI rész is.

\subsubsection{Server osztály}\label{subsubsec:serverclass}
A Server osztály fogja hallgat egy bizonyos portot, és várja, hogy a klienssel kapcsolatot létesítsen. Az osztálynak három attribútumja van: egy ip cím, port és maga a szerver, amely megmondja, hogy milyen kapcsolatot hoz létre, ebben az esetben TCP kapcsolat. Az ip címnek egy üres karakterláncot kell megadni példányosításkor. A kapcsolat létesítésében a $connect$ függvény játszik szerepet.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture0}
\caption{ctor Server}
\label{fig:ctorserver}
\end{figure}

\begin{algorithmic}[H]
\Function{\_\_init\_\_}{$self, ip\_address, port$}
	\State $self.ip\_address \gets ip\_address$
	\State $self.port \gets port$
	\State $self.server \gets$ TCP kapcsolat
\EndFunction
\end{algorithmic}

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture1}
\caption{connect Server}
\label{fig:connect}
\end{figure}

\begin{algorithmic}[H]
\Function{connect}{$self$}
	\State beállítja az opciókat
	\State összeköti a ip címet a porttal
	\State csak egy klienst hallgat
	\try
		\State várakozik a kliensre, amíg a klines csatlakozik
	\catch{socket.error}
		\State \textbf{raise} socket.error
	\endtry
\EndFunction
\end{algorithmic}

\subsubsection{Keylogger osztály}\label{subsubsec:keyloggerclass}
A keylogger osztályt a $Thread$ osztályból van származtatva, mert egy külön szálon kell, hogy fusson a GUI miatt. A GUI csak a fő szálon van engedélyezve. Ennek az osztálynak öt attribútumja van: a létrejött kapcsolat a szerver és a kliens között, a GUI, gmail cím, a hozzá tartozó jelszó és a gmail server api címe. A $connection$ és a $gui$ paraméterek egy-egy osztályt várnak, ezért kapcsolatot és a GUI-t ellenőrizni kell, hogy jó osztály került-e átadásra.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture2}
\caption{ctor Keylogger}
\label{fig:ctorkeylogger}
\end{figure}

\begin{algorithmic}[H]
\Function{\_\_init\_\_}{$self,connection,gui,email\_address,email\_password$}
	\State a bővített osztály konstruktor hívása
	\State $self.email\_address \gets email\_address$
	\State $self.email\_password \gets email\_password$
	\State $self.imap_alias \gets\ 'imap.gmail.com'$
	\If{$connection\ \textbf{is}\ Server$}
		\State $self.connection \gets connection$
	\Else
		\State \textbf{raise} $TypeError$
	\EndIf
	\If{$gui\ \textbf{is}\ GUIWindow$}
		\State $self.gui \gets gui$
	\Else
		\State \textbf{raise} $TypeError$
	\EndIf
\EndFunction
\end{algorithmic}

\justify{A $Keylogger$, a fő osztály, amelyre épül a program, kezeli a billentyűzet gombjai lenyomását. Amíg a TCP kapcsolat él, addig azon keresztül küldi a lenyomott karaktereket, amit elment a log.csv állományba a szerver oldalon, hogy a későbbiekben újra megtekinthető legyen. A log.csv állomány formátuma lenyomott billentyű ideje, karakter. Ahol az idő ``nap/hónap/év $|$ óra:perc:másodperc'' formátumu. Fentakadhat egy olyan probléma. hogy a kapcsolat valami oknál fogva megszakad, ekkor e-mail-en keresztül küldi át az adatokat. Erre kell a Figure \ref{fig:sysname}-ön látható $temp\_path$ változó, hogy a lenyomott billentyűket eltudja menteni a kliens számítógépén és azt e-mail-en keresztül elküldje. Erre szolgál a \pageref{subsubsec:keyloggerclass}. oldalon a 4.1.2 alatt megemlített gmail cím és a hozzá kapcsolódó jelszó.}

Itt megkellett tervezni egy protokollt, ami a kommunikáció alapja. A protokoll a következő képpen néz ki:
\begin{table}[H]
\centering
\label{tab:protocol}
\caption{protokoll}
\begin{tabular}{|c|c|c|}
\hline
\textbf{type} & \textbf{time} & \textbf{information} \\
\hline
4-5 & 11 & ? \\
\hline
\end{tabular}
\end{table}
A $type$ mező megmondja, hogy milyen típusu adat fog jönni az $information$ mezőben. Ez 4 vagy 5 bájt lehet. Előfodulható lehetőségek:
\begin{itemize}
\item char - egy karakter
\item image - egy képernyőkép bájtsorozata
\item wcpic - egy webkamera kép bájtsorozata
\item audio - egy audio állomány bájtsorozata
\end{itemize}
A $time$ mezőben egy időbéjeg található, amely megmondja, hogy a csomag mikor érkezett. Ez 11 bájt lehet. Formátuma: ``nap\_óra\_perc\_másodperc''.\\
Az $information$ mezőben vannak azok az adatok amelyeket a szerver fel kell dolgozzon. Ezt a ennek a mezőnek nem lehet pontos méretet adni, mert nem tudjuk előre megmondani, hogy mekkora adatot küld, kivétel a karakter. A python nyelvben nincsenek korlátok ebből a szempontból.

A továbbiakban egy végtelen ciklust alkalmazva az adatok feldolgozásra kerülnek, ha a TCP kapcsolat még nem zárult be. Az adatok beíródnak egy-egy állományba. Ha az $infomation$ mezőben az ``Error'' szöveg érkezik, akkor sikertelen volt az adatküldés, és a program egy üzenetet ír ki a vezérlőablakra, hogy tudassa a sikertelen folyamatot. A $data$ változó tartalmazza a protokill által található információt.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture3}
\caption{kép}
\label{fig:imgprocess}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture4}
\caption{karakter}
\label{fig:charprocess}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture5}
\caption{webkamera}
\label{fig:webcamprocess}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture6}
\caption{audio}
\label{fig:audioprocess}
\end{figure}

\begin{algorithmic}[H]
\If{$data[0] = 'image'$}
	\If{$data[2] \neq Error$}
		\State beírja egy új állományba a $data[2]$ tartalmát
	\EndIf
\ElsIf{data[0] = 'char'}
	\State beírja a $log.csv$ állományba az információt
	\If{a gui fut}
		\State beírja a guiba
	\EndIf
\ElsIf{data[0] = 'wcpic'}
	\If{$data[2] \neq Error$}
		\State beírja egy új állományba a $data[2]$ tartalmát
	\EndIf
\ElsIf{data[0] = 'audio'}
	\If{$data[2] \neq Error$}
		\State beírja egy új állományba a $data[2]$ tartalmát
	\EndIf
\EndIf
\end{algorithmic}

Ha a TCP kapcsolat felbomlik, akkor e-mail-en keresztül lesz továbbítva az adat csatolmányban. Ahoz, hogy írni és olvasni is tudjunk e-mail-t python kódból, a google fióknál be kell legyen kapcsolva a ``Less secure app access''. A gmail fióknál pedig a következőt kell engedélyezni: Settings $\rightarrow$ See all settings $\rightarrow$ Forwarding and POP/IMAP $\rightarrow$ IMAP access $\rightarrow$ Enable IMAP.

Előszőr csatlakozni kell a megadott gmail címhez. Ez után megnézzük, hogy jött-e olyan e-mail, amit még nem láttunk, ha igen, akkor ellenőrizzük, hogy a saját gmail címünkről jott-e. Ha minden feltétel teljesül, akkor megnyitjuk az e-mail-t és letöltjük a csatolmányokat. Itt két csatolmány érkezik: egy képernyőkép és egy log állomány, amelyben a lenyomott billentyűk vannak naplózva. Ezt a folyamatot ismételjük addig, amíg nincsen hiba. Hiba alatt a következőket lehet érteni: nem engedi a csatlakozást a gmail api szerver, nem tudja megnyitni az elküldött csatolmányokat.

A $get\_attachments$ függvény segítségével tölti le a csatolmányokat, amelynek egy paramétere van: az üzenet. Az üzenet tartalmazza a teljes üzenetet bájtokban, tehát, hogy kiől jött az üzenet, kinek küldték, a téma, maga az üzenet törzse, a csatolmányok. A függvény ezen az üzeneten megy végig és ha talal csatolmányt azt letölti, más szóval megnyit egy állományt binárisan és beleírja a tartalmát.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture7}
\caption{get\_attachments}
\label{fig:getatt}
\end{figure}

\begin{algorithmic}[H]
\Function{get\_attachments}{$self,msg$}
	\For{$part \gets \Call{msg.walk}{}$}
		\If{$\Call{part.get\_content\_maintype}{$$} = 'multipart'$}
			\State \textbf{continue}
		\EndIf
		\If{$\Call{part.get}{'Content-Disposition'} = None$}
			\State \textbf{continue}
		\EndIf
		
		\State $filename \gets \Call{part.get\_filename}{$$}$
		\If{$filename$ nem üres}
			\State letölti az állományt
		\EndIf
	\EndFor
\EndFunction
\end{algorithmic}

A harmadik osztály a $MenuHandler$, amely segítségével más feladatot is adhatunk a kliensnek a billentyűzet naplózása mellett. Ez az osztály is a $Thread$ osztályból származik, mert egy külön szál kell amiatt, hogy ne blokkolódjon az adatfeldolgozás. Ennek az osztálynak egy attribútumja van: a kapcsolat. Ez a kapcsolat fogja megvalósítani az opciók küldését a kliensnek. Itt négy opció lehet:
\begin{itemize}
\item 1) Take screenshot - képernyőkép
\item 2) Webcam picture - webkamerakép
\item 3) Record audio - audio felvétel
\item 4) Exit - bezárja a TCP kapcsolatot
\end{itemize}
Természetesen le van kezelve, ha nem 1-től 4-ig adunk meg számokat, akkor egy üzenetet ír ki: ``Wrong option!'', vagy ha csak lenyomjuk az ENTER karaktert, akkor egyszerűen új sórba ugrik.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture8}
\caption{ctor MenuHandler}
\label{fig:ctormenu}
\end{figure}

\begin{algorithmic}[H]
\Function{\_\_init\_\_}{$self,connection$}
	\State bővített osztály konstruktor hívása
	\If{$connection\ \textbf{is}\ Server$}
		\State $self.connection \gets connection$
	\Else
		\State \textbf{raise} $TypeError$
	\EndIf
\EndFunction
\end{algorithmic}

\subsection{Kliens}\label{subsec:client}
A kliensnél nagyjából ugyan az a felállítás, mint a szerver oldalon. Előszőr, meg kell nézni, hogy milyen rendszeren van futtatva, lásd Figure \ref{fig:sysname}. Ez után létre van hozva a ``Client'' osztály, amelynek négy attribútumja van: ip cím, port, a kliens és a gép ip címje. Példányosításkor a szerver ip címét kell megadni. A kliens attribútum megmondja, hogy milyen kapcsolatot hozunk létre, ebben az esetben TCP, mert a szerver is TCP.
\subsubsection{Client osztály}\label{subsubsec:clinetclass}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture9}
\caption{ctor Client}
\label{ctorclient}
\end{figure}

\begin{algorithmic}[H]
\Function{\_\_init\_\_}{$self,ip\_address,port$}
	\State $self.ip\_address \gets ip\_address$
	\State $self.port \gets port$
	\State $self.client \gets$ TCP kapcsolat
\EndFunction
\end{algorithmic}
A kapcsolat létesítésében a $connect$ függvény játszik szerepet. A $socket$ modul $gethostname$ függvényét alkalmazva megkapjuk a gép ip címjét, amely csak egy lokális ip cím. A darwin rendszereknél hozzá kell fűzni a ``.local'' karakterláncot, másképp egy exception lép fel.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture10}
\caption{connect Clinet}
\label{fig:connectclient}
\end{figure}

\begin{algorithmic}[H]
\Function{connect}{$self$}
	\State kapcsolódik a szerverhez
	\try
		\State $self.pc\_ip \gets$ számítógép ip címe
	\catch{socket.gaierror}
		\try
			\State $self.pc\_ip \gets$ számítógép ip címe + '.local'
		\catch
			\State $self.pc\_ip \gets$ 'Unknown'
		\endtry
	\catch{}
		\State $self.pc\_ip \gets$ 'Unknown'
	\endtry
\EndFunction
\end{algorithmic}

\subsubsection{KeyLoggerClient osztály}\label{subsubsec:keyloggerclientclass}
Ez az osztály valósítsa meg a lenyomott billentyűk kezelését. Hat attribútumot tartalmazó osztály: a kapcsolat, gmail cím, gmail jelszó, gmail api, gmail port és a lenyomott billentyűt tartalmazó változó.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture11}
\caption{ctor KeyLoggerClient}
\label{fig:ctorkeyloggerclient}
\end{figure}

\begin{algorithmic}[H]
\Function{\_\_init\_\_}{$self,connection,email\_address,email\_password$}
	\State $self.email\_address \gets email\_address$
	\State $self.email\_password \gets email\_password$
	\State $self.smtp\_alias \gets\ 'smtp.gmail.com'$
	\State $self.smtp\_port \gets 587$
	\State $self.keys \gets None$
	\If{$connection\ \textbf{is}\ Client$}
		\State $self.connection \gets connection$
	\Else
		\State \textbf{raise} $TypeError$
	\EndIf
\EndFunction
\end{algorithmic}
Az első adat nem követi a megállapított protokolt. Ez az adat tartalmazza a kliens rendszerének információit:
\begin{itemize}
\item system name
\item device name
\item release
\item version
\item architecture
\item cpu info
\item user name
\item ip address
\end{itemize}
Ezek után el lesz indítva egy halgató, amely lehalgatja a számítógéphez csatlakoztatott billentyűzetet, amely akkor írja felül a $keys$ attribútumot, amikor a felhaszáló elengedi a billentyűt. Az attribútum felülírásáról az $on\_release$ függveny gondoskodik.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture12}
\caption{Listener}
\label{fig:listener}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics{../images/Capture13}
\caption{on\_release}
\label{fig:onrelease}
\end{figure}

\begin{algorithmic}[H]
\State $keyboard\_listener \gets \Call{Listener}{$on\_release$}$
\State $keyboard\_listener.\Call{start}{$$}$
\Function{on\_release}{$self,key$}
	\State $self.keys \gets key$
\EndFunction
\end{algorithmic}

A billentyűzet lehalgató után egy végtelen ciklusban felépítődik az adat, amit a kapcsolaton keresztül elküld. Minden adatépítés után a $keys$ változó a $None$ értéket veszi fel. Adatépítésre és küldésre csak akkor kerül sor, ha a $keys$ változó nem $None$.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture14}
\caption{adatépítés}
\label{fig:databuild}
\end{figure}
\begin{algorithmic}[H]
\If{$self.keys \neq None$}
	\State $date\_time \gets \Call{get\_time}{$$}$
	\State $key \gets \Call{str}{$self.keys$}.\Call{replace}{$''`'',''''$}$
	\State $data \gets [''char'', date\_time, key]$
	\State $self.keys \gets None$
	\State $data \gets \Call{str}{$data$}$
\EndIf
\end{algorithmic}
\justify{A $get\_time$ függvény visszatéríti az adott időt ``nap/hónap/év | óra:perc:másodperc'' formátumban.}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture15}
\caption{get\_time}
\label{fig:gettime}
\end{figure}
\begin{algorithmic}[H]
\Function{get\_time}{}
	\State $date\_time \gets$ dd/mm/yyyy $|$ HH:MM:SS formátumban az idő
\EndFunction
\end{algorithmic}
\justify{A $keys$ változóba karakterként vagy karakterláncként kerül a lenyomott billentyű, ezért le kell cseélni a szélső idézőjeleket üres karakterekre. Karakter helyett akkor kerül karakterlánc, ha olyan karaktereket nyomunk le, amelyek nem nyomtathatóak, például: ENTER, SPACE, F1, F2, stb. Ilyenkor $Key.enter$ vagy $Key.space$ stb formátumban kapjuk meg.}

Ha a kapcsolat felbomlott, akkor e-mail-en keresztül küldi tovább az adatokat óránként. Itt lépnek érvénybe a gmail cím, a jelszó, a gmail api, és a gmail port, lásd Figure \ref{fig:ctorkeyloggerclient}. Az adat felépítése ugyan úgy zajlik, mint eddig, lásd Figure \ref{fig:databuild}. Ebben az esetben a lenyomott billentyűket összegyűjtjük egy állományba és azt csatoljuk később az e-mail-hez a képernyőképpel együtt. Egy e-mail felépítése python-ban:
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture16}
\caption{e-mail törzse}
\label{fig:emailbody}
\end{figure}
\begin{algorithmic}[H]
\State $msg \gets \Call{MIMEMultipart}{$$}$
\State $msg['From'] \gets email\_address$
\State $msg['To'] \gets email\_address$
\State $msg['Subject'] \gets 'Keylogger result'$
\State $body \gets date\_time$
\State $body \gets \Call{MIMEText}{$body,'plain'$}$
\State $msg.\Call{attach}{$body$}$
\end{algorithmic}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture17}
\caption{e-mail csatolmányok}
\label{fig:emailattach}
\end{figure}
\begin{algorithmic}[H]
\State $file\_attachment \gets \Call{MIMEBase}{$'application','octet-stream'$}$
\State $image\_attachment \gets \Call{MIMEBase}{$'application','octet-stream'$}$
\State $file\_attachment.\Call{set\_payload}{$fájl tartalma$}$
\State base64 kódolás
\State hozzácsatolás az e-mail-hez
\State képernyőkép készítés
\State $image\_attachment.\Call{set\_payload}{$fájl tartalma$}$
\State base64 kódolás
\State hozzácsatolás az e-mail-hez
\end{algorithmic}
Miután felépítettük az e-mail-t, kell csatlakozni a gmail szerverhez és elküldeni azt. Ha az e-mail sikeresen el lett küldve, akkor az az állomány, amelybe a lenyomott billentyűket mentettük, törlésre kerül, hogy ne küldjük el ugyan azt mégegyszer. A $content$ változó tartalmazza a teljes e-mail-t a csatolmányokkal együtt.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture18}
\caption{e-mail küldés}
\label{fig:sendemail}
\end{figure}
\begin{algorithmic}[H]
\State $content \gets$ üzenet karakterlánc formátumban
\State kapcsolat létesítés a gmail szerverrel
\State bejelentkezés
\State e-mail küldés
\State fájlok törlése
\end{algorithmic}

\subsubsection{MenuHandlerClient osztály}\label{subsubsec:menuhandlerclinet}
A $MenuHandlerClient$ osztály foglalkozik az opciók fogadásával, és az opciók által elvégzett feladatokkal. Ez az osztály egy külön szálon kell, hogy fusson, máskülönben blokkolná a fő szálat, ahol a billentyűzetet hallgató osztály fut, lasd \pageref{subsubsec:keyloggerclientclass}. oldal 4.2.2, ezért a $Thread$ osztályból származtatjuk.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture19}
\caption{ctor MenuHandlerClient}
\label{fig:ctormenuhandlerclient}
\end{figure}
\begin{algorithmic}[H]
\Function{\_\_init\_\_}{$self,connection$}
	\State bővített osztály konstruktor hívása
	\If{$connection\ \textbf{is}\ Client$}
		\State $self.connection \gets connection$
	\Else
		\State \textbf{raise} $TypeError$
	\EndIf
\EndFunction
\end{algorithmic}
A szervertől kapott opciók döntik el, hogy milyen adatot épít fel, és küldi el a program:
\begin{itemize}
\item 1 - képernyőkép
\item 2 - webkamerakép
\item 3 - hangrögzítés
\item 4 - felbontja a kapcsolatot
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture20}
\caption{képernyőkép}
\label{fig:image}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture21}
\caption{webkamerakép}
\label{fig:wcpic}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture22}
\caption{hangrögzítés}
\label{fig:audio}
\end{figure}

\begin{algorithmic}[H]
\If{\Call{take\_screenshot}{$temp\_path$}}
	\If{$screenshot.png$ fájl létezik}
		\State $data.\Call{append}{$fájl tartalma$}$
	\Else
		\State $data.\Call{append}{$'Error'$}$
	\EndIf
\Else
	\State $data.\Call{append}{$'Error'$}$
\EndIf
\If{\Call{take\_webcam\_picture}{$temp\_path$}}
	\If{$wc\_picture.png$ fájl létezik}
		\State $data.\Call{append}{$fájl tartalma$}$
	\Else
		\State $data.\Call{append}{$'Error'$}$
	\EndIf
\Else
	\State $data.\Call{append}{$'Error'$}$
\EndIf
\If{\Call{record\_audio}{$temp\_path$}}
	\If{$rec\_audio.wav$ fájl létezik}
		\State $data.\Call{append}{$fájl tartalma$}$
	\Else
		\State $data.\Call{append}{$'Error'$}$
	\EndIf
\Else
	\State $data.\Call{append}{$'Error'$}$
\EndIf
\end{algorithmic}

A Figure \ref{fig:image} $take\_screenshot$ függvénye fogja megcsinálni a képernyőképet. Ugyan ez érvényes a Figure \ref{fig:wcpic} $take\_webcam\_picture$ és a Figure \ref{fig:audio} $record\_audio$ függvényekre is:
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture23}
\caption{take\_screenshot}
\label{fig:takeimage}
\end{figure}
\begin{algorithmic}[H]
\Function{take\_screenshot}{$save\_path$}
	\try
		\State képernyőkép készítése
	\catch{}
		\State \Return $False$
	\endtry
	\State \Return $True$
\EndFunction
\end{algorithmic}

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture24}
\caption{take\_webcam\_picture}
\label{fig:takewcpic}
\end{figure}
\begin{algorithmic}[H]
\Function{take\_webcam\_picture}{$save\_path$}
	\State kamera előkészítése
	\If{sikeres kamera megnyitás}
		\State elment egy képet
		\State \Return $True$
	\EndIf
	\State \Return $False$
\EndFunction
\end{algorithmic}

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture25}
\caption{record\_audio}
\label{fig:recordaud}
\end{figure}
\begin{algorithmic}[H]
\Function{record\_audio}{$save\_path$}
	\State $1024$ bájtos részek
	\State $int16$ formátum
	\State $2$ csatorna
	\State $44100 hz$ hullámhossz
	\State $10$ másodperces időintervalum
	\try
		\State hangfelvétel készítése
		\State hangfelvétel lementése
	\catch{}
		\State \Return $False$
	\endtry
	\State \Return $True$
\EndFunction
\end{algorithmic}
A hangrögzítés egy kicsivel másképp kezelendő, mert meg kell mondani, hogy egy részt hány bájton abrázoljon (1024), milyen formátumba ábrázolja (16 bit int), hány csatornán ($2 = 0$ és $1$) ábrázolja a hanghullámokat, mekkora frekvencián (44.1 kHz) és hány másodperces felvételt akarunk elmenteni.

\subsection{GUI}\label{subsec:gui}
A GUI akkor lép működésbe, amikor a kliens csatlakozott a szerverhez, és addig funkcionál, amíg be nem zárják. Van egy $Date\ \&\ Time$ és egy $Characters$ mezője. Az első oszlop tartalmazza az idő béjeget, hogy mikor volt egy bizonyos karakter megnyomva. A második oszlop a lenyomott karaktereket taartalmazza kezdésben. Három gomb találhato az ablak tetején: $PC\ Information$, $Characters$ és $Words$.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/GUI\ final}
\caption{GUI}
\label{fig:gui}
\end{figure}
Ha a $PC\ Information$ gomb kerül megnyomásra, akkor felugrik egy másik ablak, amely tartalmazza a felhasználó (target) redszerinformációit, lásd \pageref{subsubsec:keyloggerclientclass} oldal.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/Capture28}
\caption{PC Information button}
\label{fig:pcinfo}
\end{figure}
A $Characters$ és a $Words$ gombok a megjelenítésért felelnek. Ahogyan a nevük is mondja, a $Characters$ gomb csak a karaktereket mutatja, míg a $Words$ gomb felépíti a szavakat, és azokat mutatja. 

\section{A rendszer felhasználása (szoftverek és hardverek esetében)}\label{sec:useage}

\section{Üzembe helyezés és kísérleti eredmények (szoftverek és hardverek esetében)}\label{sec:testcases}

\section{Következtetések}\label{sec:conc}

\section{Irodalomjegyzék}\label{sec:irod}

\section{Függelék (beleértve a forráskódot és dokumentációt tartalmazó adathordozót)}\label{sec:dep}

\end{document}